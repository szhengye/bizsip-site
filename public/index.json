[{"authors":null,"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"http://bizsip.bizmda.com/author/nelson-bighetti/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/nelson-bighetti/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"Nelson Bighetti","type":"authors"},{"authors":["吳恩達"],"categories":null,"content":"吳恩達 is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":-62135596800,"objectID":"da99cb196019cc5857b9b3e950397ca9","permalink":"http://bizsip.bizmda.com/author/%E5%90%B3%E6%81%A9%E9%81%94/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E5%90%B3%E6%81%A9%E9%81%94/","section":"authors","summary":"吳恩達 is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology","tags":null,"title":"吳恩達","type":"authors"},{"authors":null,"categories":null,"content":"   目录  一、开发目标 二、系统架构 三、部署方式 Courses in this program    一、开发目标 Biz-SIP是一套基于领域驱动设计（DDD），用于快速构建金融级云原生架构的服务整合中间件，包含了在金融场景里锤炼出来的最佳实践。 主要功能有：\n 支持服务接入和服务调用：金融应用随着前后端分离架构、微服务架构、中台战略、产业互联互通的实施必将产生大量的各种协议业务系统的整合，系统之间的相互调用和依赖情况也随之越来越多和复杂，Biz-SIP中间件支持全面整合企业内外部应用和接口，打造业务中台； 支持标准接口接入和非标接口接入：标准接口采用标准的微服务接口接入，非标接口支持开箱即用的常用接口适配器，并支持个性化服务接入端的二次开发； 服务接入和服务调用，支持常用的开箱即用、可配置的消息格式适配能力和通讯协议适配能力；  支持可配置的消息适配器：支持JSON、XML、定长、有分隔符、8583等报文等报文的解包和打包，并支持二次开发扩展； 支持可配置的协议适配器：支持WebService、RESTful、消息中间件、TCP等通讯协议的对接，并支持二次开发扩展；   支持多种服务整合和编排方式：业务系统与业务系统之间、关联合作伙伴之间的系统调用都相应存在大量的服务相互调用和逻辑重组需求，目前支持脚本和Java SDK来进行服务的整合和编排； 丰富的内部服务集成：还可以在服务整合和编排中，加入数据库、内容存储、加密计算、AI计算、分布式事务等内部服务节点，从而进一步丰富服务整合的能力。 其它功能：支持服务消息中域级校验规则和服务级的阻断校验规则。  适合业务场景\n 中台战略：作为企业中台架构中的前置服务化平台的服务管理、发布平台 开放平台：将企业内部服务以OpenAPI方式对公众市场开放，共同打造应用场景 微服务架构：作业微服务架构中API相互调用、聚合、编排的统一平台 遗留系统：作为集成企业遗留系统的统一集成平台 协议转换：作为多个服务开发体系(SpringCloud、Dubbo、.Net)的统一服务转换和管理平台 逻辑重组：作为企业大量的API服务与服务之间的逻辑重组平台 系统解藕：解决系统服务之间相互藕合的问题 敏捷交付：可快速重组业务逻辑、敏捷交付业务应用，比传统代码模式交付速度提升80%  二、系统架构 系统分层架构，如下图所示：\n整个Biz-SIP中间件主要包括：服务聚合器（App Integrator）、服务接入模块（Source）、服务调用模块（Sink）、Open API接口和内部基础服务五大块，其中：\n 服务整合器（App Integrator）：负责服务的整合和编排，对Source模块接入的聚合服务，进行服务编排，并通过Sink模块接入要编排的服务。 服务接入模块（Source）：负责聚合服务的接入，包括通讯协议适配和消息格式转换，并统一接入Integrator。 服务调用模块（Sink）：统一被Integrator所调用，负责接入要编排的服务，包括和外部服务对接时的通讯协议适配和消息格式转换。 开放API接口（Open API）：对外提供的标准的API接口，提供所有聚合服务的接入，后面是接入服务聚合器（Integrator）。 内部基础服务：内置数据库、日志、延迟服务管理等常用的服务，由Integrator编排到聚合服务中，其中延迟服务是比较重要的服务，主要用于Saga分布式事务和SAF（Store And Forward，消息的存储转发）。  逻辑架构图，如下图所示： 三、部署方式 Biz-SIP中间件支持以下3种部署方式：\n 主机部署：支持基于SpringBoot轻量快速部署，以及基于SpringCloud中大型集群化系统环境部署。 Kubernetes容器部署：支持集群化部署，针对高可用、高并发的大规模系统环境部署。 Istio服务网格部署：实现基于云原生的持续交付和DevOps运维体系，支持超大规模系统环境部署。  Courses in this program  快速启动 快速安装并运行Biz-SIP中间件，并运行相关的测试案例.   系统配置 Biz-SIP中间件通过配置来构建系统的介绍。   系统开发 介绍使用Java代码来开发基于Biz-SIP中间件的系统。   接口规范 介绍Biz-SIP中间件各模块间的接口类型和通讯方式。   运行原理 介绍Biz-SIP中间件主要场景的运行机制。   扩展开发 介绍对Biz-SIP中间件模块进行增加类型和扩展功能的进阶开发。   xbank示例项目 通过xbank项目来介绍用Biz-SIP中间件开发一个系统的全流程    Begin the course   ","date":1632441600,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1632441600,"objectID":"44eb1c94088314675e3eec1f7b06ada3","permalink":"http://bizsip.bizmda.com/doc/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/","section":"doc","summary":"Biz-SIP是一套基于领域驱动设计（DDD），用于快速构建金融级云原生架构的服务整合中间件，包含了在金融场景里锤炼出来的最佳实践。","tags":null,"title":"Biz-SIP服务整合中间件","type":"book"},{"authors":null,"categories":null,"content":"快速安装并运行Biz-SIP中间件，并运行相关的测试案例.\n一、安装 1 项目源码下载  从“https://gitee.com/szhengye/biz-sip”中Clone下载项目源码，SpringBoot版本下载springboot分支，SpringCloud版本下载springcloud分支。 在Eclipse或IDEA中作为Maven项目导入。  2 MySQL安装  安装MySQL镜像  docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=bizsip123456 -d mysql  建库  执行项目中sql/sample.sql脚本，以建立sip演示库。\n3 Redis安装 docker run -p 6379:6379 -d redis:latest redis-server  4 RabbitMQ安装 docker pull rabbitmq docker run -d --name rabbitmq -e RABBITMQ_DEFAULT_USER=springcloud -e RABBITMQ_DEFAULT_PASS=springcloud -p 15672:15672 -p 5672:5672 rabbitmq:management # 下载延迟队列插件，并拷贝到容器中相关目录 docker cp rabbitmq_delayed_message_exchange-3.8.0.ez rabbitmq:/plugins # 进入容器交互终端模式，用\u0026quot;docker ps\u0026quot;命令查询RabbitMQ的容器ID docker exec -it \u0026lt;容器ID\u0026gt; bash # 执行命令启用延迟队列插件 rabbitmq-plugins enable rabbitmq_delayed_message_exchange  5 Nacos安装（SpringCloud版本）  下载Nacos镜像  docker pull nacos/nacos-server  启动Nacos镜像  docker run --env MODE=standalone --name nacos -d -p 8848:8848 nacos/nacos-server # 登录密码默认nacos/nacos # standalone 代表单机模式运行，非集群模式  访问Nacos，默认账号/密码：nacos/nacos，访问地址：http://localhost:8848/nacos/index.html  二、配置 1 integrator相关配置文件 application.yml文件：\nspring: profiles: active: local  application-local.yml文件：\nserver: port: 8888 spring: application: name: bizsip-integrator cloud: nacos: discovery: server-addr: bizsip-nacos:8848 # 以下配置在Istio部署中打开，以不采用NACOS注册中心，而采用etcd注册机制 # cloud: # service-registry: # auto-registration: # enabled: false #禁用注册中心服务 datasource: url: jdbc:mysql://bizsip-mysql/sip username: root password: bizsip123456 driver-class-name: com.mysql.jdbc.Driver redis: redisson: enable: true host: bizsip-redis port: 6379 timeout: 6000 database: 0 lettuce: pool: max-active: 10 # 连接池最大连接数（使用负值表示没有限制）,如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽) max-idle: 8 # 连接池中的最大空闲连接 ，默认值也是8 max-wait: 100 # # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException min-idle: 2 # 连接池中的最小空闲连接 ，默认值也是0 shutdown-timeout: 100ms rabbitmq: virtual-host: / host: bizsip-rabbitmq port: 5672 username: springcloud password: springcloud listener: simple: concurrency: 5 max-concurrency: 15 prefetch: 10 bizsip: config-path: /var/bizsip/config logging: level: com.bizmda.bizsip: info  其中：\n server.port：服务整合器（Integrator）的微服务端口，建议用8888端口，避免和其它端口相冲突。 spring.datasource.*：为数据库相关配置，应连接对应的数据库。 spring.redis.*：为Redis相关配置，连接对应的Redis。 spring.rabbitmq.*：为RabbitMQ相关配置，连接RabbitMQ中间件。 bizsip.config-path：配置成项目下sample/config的实际安装目录。 logging.level.com.bizmda.bizsip：日志级别，一般设置为info。  2 sample/sample-sink模块相关配置文件 application.yml文件：\nspring: profiles: active: local  application-local.yml文件：\nserver: port: 8001 spring: application: name: bizsip-sample-sink cloud: nacos: discovery: server-addr: bizsip-nacos:8848 # 以下配置在Istio部署中打开，以不采用NACOS注册中心，而采用etcd注册机制 # cloud: # service-registry: # auto-registration: # enabled: false #禁用注册中心服务 rabbitmq: virtual-host: / host: bizsip-rabbitmq port: 5672 username: springcloud password: springcloud listener: simple: concurrency: 5 max-concurrency: 15 prefetch: 10 bizsip: config-path: /Users/shizhengye/IdeaProjects/biz-sip/sample/config # config-path: /var/bizsip/config # sink-id: sink-nothing\t#如果引用了com.bizmda.bizsip.sink.controller.SinkController，就需要配置这个参数 logging: level: com.bizmda.bizsip: debug  其中：\n server.port：为sample服务接入模块的RESTful服务端口，建议用8080。 spring.rabbitmq.*：为RabbitMQ相关配置，连接RabbitMQ中间件。 bizsip.config-path：配置成项目下sample/config的实际安装目录。 sink-id：如果引用了Sink默认Controller（com.bizmda.bizsip.sink.controller.SinkController），就需要配置这个参数 logging.level.com.bizmda.bizsip：日志级别，一般设置为info。  3 sample/sample-source模块相关配置文件 application.yml文件：\nspring: profiles: active: local  application-local.yml文件：\nserver: port: 8080 spring: application: name: bizsip-sample-source cloud: nacos: discovery: server-addr: bizsip-nacos:8848 # 以下配置在Istio部署中打开，以不采用NACOS注册中心，而采用etcd注册机制 # cloud: # service-registry: # auto-registration: # enabled: false #禁用注册中心服务 bizsip: config-path: /var/bizsip/config integrator-url: http://bizsip-integrator/api logging: level: com.bizmda.bizsip: info  其中：\n server.port：为sample服务调用模块的微服务端口，建议用8001，不要其它端口相冲突。 bizsip.integrator-url：为服务整合器（Integrator）的服务接口url，原则上不需要修改。 bizsip.config-path：配置成项目下sample/config的实际安装目录。 logging.level.com.bizmda.bizsip：日志级别，一般设置为info。  4 source/netty-source模块相关配置文件 application.yml文件：\nspring: profiles: active: local  application-local.yml文件：\nserver: port: 8090 spring: application: name: bizsip-netty-source cloud: nacos: discovery: server-addr: bizsip-nacos:8848 # 以下配置在Istio部署中打开，以不采用NACOS注册中心，而采用etcd注册机制 # cloud: # service-registry: # auto-registration: # enabled: false #禁用注册中心服务 bizsip: config-path: /var/bizsip/config integrator-url: http://bizsip-integrator/api source-id: source1 netty: port: 10002 logging: level: com.bizmda.bizsip: debug  其中：\n server.port：为sample服务调用模块的微服务端口，建议用8090，不要其它端口相冲突。 bizsip.integrator-url：为服务整合器（Integrator）的服务接口url，原则上不需要修改。 bizsip.config-path：配置成项目下sample/config的实际安装目录。 bizsip.source-id：为当前source模块的Source ID。 logging.level.com.bizmda.bizsip：日志级别，一般设置为info。  三、启动系统 测试用例架构如下图所示：\n1 启动服务整合器（Integrator） 运行integrator模块下“IntegratorApplication.java”\n2 启动Sample Sink模块 运行sample/sample-sink模块下“SampleSinkApplication.java”\n3 启动Sample Source模块 运行sample/sample-source模块下“SampleSourceApplication.java”\n4 启动Netty TCP Source模块（可选） 运行source/netty-source模块下“NettySourceApplication.java”\n5 启动OpenAPI网关（SpringCloud版本，可以不用开启） 运行api-gateway模块下“GatewayApplication.java”。 对于后续测试案例的调用发起，都是直接发给Integrator服务整合器的，端口是8888；如果需要从OpenAPI网关发起，端口是8000。这二种情况的返回结果是一致的。 后续测试案例都是直接发给Integrator服务整合器的，目前端口是8888。\n四、运行Sample测试案例 1 简单服务处理 通过Biz-SIP的开放API接口发送请求，由服务整合器处理后，直接返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/sample1\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;62001818\u0026quot;,\u0026quot;sex\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;email\u0026quot;:\u0026quot;123232@163.com\u0026quot;,\u0026quot;mobile\u0026quot;:\u0026quot;18601872345\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;414ac54e35d446a9bf36a7bae189eb2b\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1610334191563, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;62001818的账户名...\u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;mobile\u0026quot;: \u0026quot;18601872345\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;62001818\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;123232@163.com\u0026quot; } }  2 简单服务转发 通过Biz-SIP的开放API接口，调用CRM服务（用CrmServer.java类作为模拟），查询返回对应的账户名称。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/sample2\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;f30a96f6d73b4f44853b56a29688e1aa\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914563646, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; } }  3 非标接口接入 通过非标API接口上送服务请求，实现原来通过标准API接口调用openapi/sample2服务。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -X POST --data '{\u0026quot;serviceId\u0026quot;:\u0026quot;/openapi/sample2\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8080/source1|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;9a0421faccf14f7b8f8dfd9916e8aca2\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1619768390392, \u0026quot;data\u0026quot;: \u0026quot;{\\\u0026quot;accountName\\\u0026quot;:\\\u0026quot;张三\\\u0026quot;,\\\u0026quot;accountNo\\\u0026quot;:\\\u0026quot;003\\\u0026quot;,\\\u0026quot;serviceId\\\u0026quot;:\\\u0026quot;/openapi/sample2\\\u0026quot;}\u0026quot; }  4 调用多个服务 通过Biz-SIP的开放API接口，调用Server1返回帐户名称，调用Server2返回账户余额。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/sample4\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;67e451ea394a4714b3be6b4496ead1e6\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914708687, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;, \u0026quot;balance\u0026quot;: 500, \u0026quot;accountNo\u0026quot;: \u0026quot;005\u0026quot; } }  5 简单XML消息转换 通过Biz-SIP的开放API接口，用simple-xml消息格式调用Server3，Server3会调用EchoServer打印消息报文，并用原服文返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/sample5\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;balance\u0026quot;: 500,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;41112613fd4d4d9a85d8ba420ed5dbd5\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914764308, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;, \u0026quot;balance\u0026quot;: 500, \u0026quot;accountNo\u0026quot;: \u0026quot;005\u0026quot; } }  Server3接入EchoServer类打印的消息：\nEchoServer传入消息:\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;accountName\u0026gt;王五\u0026lt;/accountName\u0026gt;\u0026lt;balance\u0026gt;500\u0026lt;/balance\u0026gt;\u0026lt;accountNo\u0026gt;005\u0026lt;/accountNo\u0026gt;\u0026lt;/root\u0026gt;  6 复杂JSON消息转换 通过Biz-SIP的开放API接口，用velocity-json消息格式调用Server4，Server4会调用EchoServer打印消息报文，并用原服文返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server4\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;f6e36e068f824d57840222bafb9f0fac\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914809605, \u0026quot;data\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;女\u0026quot;, \u0026quot;account_no\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;account_name\u0026quot;: \u0026quot;王五\u0026quot; } }  EchoServer打印日志：\nEchoServer传入消息:{sex:\u0026quot;女\u0026quot;,account_no:\u0026quot;005\u0026quot;,account_name:\u0026quot;王五\u0026quot;}  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server4\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;f2d0e28597634b1a89c4e8e4140ae8a7\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914847120, \u0026quot;data\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;男\u0026quot;, \u0026quot;account_no\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;account_name\u0026quot;: \u0026quot;王五\u0026quot; } }  EchoServer打印日志：\nEchoServer传入消息:{sex:\u0026quot;男\u0026quot;,account_no:\u0026quot;005\u0026quot;,account_name:\u0026quot;王五\u0026quot;}  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server4\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;sex\u0026quot;: \u0026quot;2\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;297c62d7fc234eb894d7447e0667f360\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914874611, \u0026quot;data\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;?\u0026quot;, \u0026quot;account_no\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;account_name\u0026quot;: \u0026quot;王五\u0026quot; } }  EchoServer打印日志：\nEchoServer传入消息:{sex:\u0026quot;?\u0026quot;,account_no:\u0026quot;005\u0026quot;,account_name:\u0026quot;王五\u0026quot;}  7 复杂XML消息转换 通过Biz-SIP的开放API接口，用velocity-xml消息格式调用Server5，Server5会调用EchoServer打印消息报文，并用原服文返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server5\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;,\u0026quot;balance\u0026quot;:100}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;04a92806779a415b94a056a390c38c58\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631418837236, \u0026quot;data\u0026quot;: { \u0026quot;account\u0026quot;: { \u0026quot;no\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;女人\u0026quot;, \u0026quot;balance\u0026quot;: 100, \u0026quot;name\u0026quot;: \u0026quot;王五\u0026quot; } } }  SampleSinkApplication打印日志：\nEchoServer传入消息:[\u0026lt;account\u0026gt; \u0026lt;name\u0026gt;王五\u0026lt;/name\u0026gt; \u0026lt;balance\u0026gt;100\u0026lt;/balance\u0026gt; \u0026lt;no\u0026gt;005\u0026lt;/no\u0026gt; \u0026lt;sex\u0026gt;女人\u0026lt;/sex\u0026gt; \u0026lt;/account\u0026gt;]  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server5\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;,\u0026quot;balance\u0026quot;:1000}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;c798f6cfc22b42e19933d860ba6bce3b\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609915845068, \u0026quot;data\u0026quot;: { \u0026quot;account\u0026quot;: { \u0026quot;no\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;女人\u0026quot;, \u0026quot;balance\u0026quot;: 1000, \u0026quot;name\u0026quot;: \u0026quot;王五\u0026quot; } } }  SampleSinkApplication打印日志：\nEchoServer传入消息:[\u0026lt;account\u0026gt; \u0026lt;name\u0026gt;王五\u0026lt;/name\u0026gt; \u0026lt;balance\u0026gt;1000\u0026lt;/balance\u0026gt; \u0026lt;no\u0026gt;005\u0026lt;/no\u0026gt; \u0026lt;sex\u0026gt;女人\u0026lt;/sex\u0026gt; \u0026lt;/account\u0026gt;]  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server5\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;sex\u0026quot;: \u0026quot;2\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;,\u0026quot;balance\u0026quot;:1000}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;8014463d1c7d451cb47c279973931ba0\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609915967831, \u0026quot;data\u0026quot;: { \u0026quot;account\u0026quot;: { \u0026quot;no\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;不知道\u0026quot;, \u0026quot;balance\u0026quot;: 1000, \u0026quot;name\u0026quot;: \u0026quot;王五\u0026quot; } } }  SampleSinkApplication打印日志：\nEchoServer传入消息:[\u0026lt;account\u0026gt; \u0026lt;name\u0026gt;王五\u0026lt;/name\u0026gt; \u0026lt;balance\u0026gt;1000\u0026lt;/balance\u0026gt; \u0026lt;no\u0026gt;005\u0026lt;/no\u0026gt; \u0026lt;sex\u0026gt;不知道\u0026lt;/sex\u0026gt; \u0026lt;/account\u0026gt;  8 定长消息转换 通过Biz-SIP的开放API接口，用定长消息格式调用Server6，Server6会调用EchoServer打印消息报文，并用原服文返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server6\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;balance\u0026quot;: 500,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;,\u0026quot;sex\u0026quot;:\u0026quot;0\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;f46a1f79ca0241719b4dc1bd3cc3457c\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609916044599, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;王五 \u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;balance\u0026quot;: \u0026quot;500 \u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;005 \u0026quot; } }  SampleSinkApplicationc对于Server6接入EchoServer类打印的消息：\nEchoServer传入消息:[0005 王五 500 ]  9 有分隔符消息转换 通过Biz-SIP的开放API接口，用定长消息格式调用Server7，Server7会调用EchoServer打印消息报文，并用原服文返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server7\u0026quot; -X POST --data '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;balance\u0026quot;: 500,\u0026quot;accountNo\u0026quot;:\u0026quot;005\u0026quot;,\u0026quot;sex\u0026quot;:\u0026quot;0\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;3a139d684acc4137b744625cace14267\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1610336392183, \u0026quot;data\u0026quot;: { \u0026quot;array\u0026quot;: [ [ \u0026quot;0\u0026quot;, \u0026quot;005\u0026quot; ], [ \u0026quot;王五\u0026quot;, \u0026quot;500\u0026quot; ] ] } }  SampleSinkApplicationc对于Server7接入EchoServer类打印的消息：\nEchoServer传入消息:[0,005*王五,500]  10 ISO8583消息转换 通过source controller，在sink端打包成ISO8583报文格式调用sink13，sink13会调用EchoServer打印消息报文，并用原服文返回，在sink端解包成JSON报文后返回。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; http://localhost:8080/sink13|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;91bef734f69a4da8b1be35138a4e9707\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1632041946033, \u0026quot;data\u0026quot;: { \u0026quot;msgType\u0026quot;: \u0026quot;0800\u0026quot;, \u0026quot;reserved60\u0026quot;: \u0026quot;000000000030\u0026quot;, \u0026quot;card_accptr_id42\u0026quot;: \u0026quot;898411341310014\u0026quot;, \u0026quot;systemTraceAuditNumber11\u0026quot;: \u0026quot;000001\u0026quot;, \u0026quot;switching_data62\u0026quot;: \u0026quot;53657175656e6365204e6f3132333036303733373832323134\u0026quot;, \u0026quot;card_accptr_termnl_id41\u0026quot;: \u0026quot;73782214\u0026quot;, \u0026quot;msgHead\u0026quot;: \u0026quot;31323031383430303031303334342020203432343330343430202020393031323334353637383930313233343536\u0026quot;, \u0026quot;acct_id_1_102\u0026quot;: \u0026quot;1234567890\u0026quot;, \u0026quot;fin_net_data63\u0026quot;: \u0026quot;303031\u0026quot; } }  SampleSinkApplicationc对于sink13接入EchoServer类打印的消息：\n11 调用Netty服务端 通过Biz-SIP的开放API接口，调用Netty TCP服务端。 在终端1启动：\n$ echo '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;balance\u0026quot;: 500,\u0026quot;accountNo\u0026quot;:\u0026quot;xxx\u0026quot;}'|nc -l 10001  在终端2启动：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/netty\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;999\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;bb4255801a54442ca16f0189d64b951f\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609916153979, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;, \u0026quot;balance\u0026quot;: 500, \u0026quot;accountNo\u0026quot;: \u0026quot;xxx\u0026quot; } }  终端1会显示：\n$ echo '{\u0026quot;accountName\u0026quot;: \u0026quot;王五\u0026quot;,\u0026quot;balance\u0026quot;: 500,\u0026quot;accountNo\u0026quot;:\u0026quot;xxx\u0026quot;}'|nc -l 10001 {\u0026quot;accountNo\u0026quot;:\u0026quot;999\u0026quot;}  12 Netty客户端接入 通过Netty客户端接入，来调用聚合服务。 $ echo '{\u0026quot;serviceId\u0026quot;:\u0026quot;/openapi/sample2\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}'|nc localhost 10002 {\u0026quot;accountName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;,\u0026quot;serviceId\u0026quot;:\u0026quot;/openapi/sample2\u0026quot;}  13 调用数据库操作 通过Biz-SIP的开放API接口，在脚本服务中根据上送的账号在数据表中进行查询，并直接返回查询结果。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/db1\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;002\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;19dd46603d844b40a1bce11cd2760e1c\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609924306042, \u0026quot;data\u0026quot;: [ { \u0026quot;accountName\u0026quot;: \u0026quot;李四\u0026quot;, \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;balance\u0026quot;: 200, \u0026quot;accountNo\u0026quot;: \u0026quot;002\u0026quot; } ] }  14 调用Redis操作 通过Biz-SIP的开放API接口，在脚本服务中根据上送的账号在Redis中进行存储，并直接返回查询结果。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/redis1\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;002\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;e04430bb7f754959b52a28a8a6e4456a\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609924818739, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;002\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;002\u0026quot; } }  redis\u0026gt;get account_no \u0026quot;002\u0026quot;  15 通过事务管理进行服务调用重试 通过Biz-SIP的开放API接口，在脚本服务中调用SAF服务，对server3服务进行多达5次的服务重试调用。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/safservice\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 186 0 167 100 19 598 68 --:--:-- --:--:-- --:--:-- 666 { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;f1afe72dac0842ad8912e063b7bcf593\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631513601741, \u0026quot;data\u0026quot;: { \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; } }  SampleSinkApplication日志：\n[bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:21.952 DEBUG 53605 [48E46F14E87845BE9040414A89AEFC03] [http-nio-8001-exec-1] c.b.b.s.sink.controller.Sink3Controller inMessage:BizMessage(code=0, message=null, extMessage=null, traceId=f1afe72dac0842ad8912e063b7bcf593, parentTraceId=null, timestamp=1631513601741, data={\u0026quot;retryCount\u0026quot;:1,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}) [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:21.955 DEBUG 53605 [48E46F14E87845BE9040414A89AEFC03] [http-nio-8001-exec-1] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]打包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:21.963 DEBUG 53605 [48E46F14E87845BE9040414A89AEFC03] [http-nio-8001-exec-1] com.bizmda.bizsip.sink.Sink Sink通过Connect[sink-bean]调用服务 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:21.963 DEBUG 53605 [48E46F14E87845BE9040414A89AEFC03] [http-nio-8001-exec-1] c.b.b.s.connector.SinkBeanSinkConnector 调用SinkBeanSinkConnector[com.bizmda.bizsip.sample.sink.controller.EchoServer]的process() [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:21.963 DEBUG 53605 [48E46F14E87845BE9040414A89AEFC03] [http-nio-8001-exec-1] c.b.b.sample.sink.controller.EchoServer EchoServer传入消息:[\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;retryCount\u0026gt;1\u0026lt;/retryCount\u0026gt;\u0026lt;accountNo\u0026gt;003\u0026lt;/accountNo\u0026gt;\u0026lt;/root\u0026gt;] [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:21.964 DEBUG 53605 [48E46F14E87845BE9040414A89AEFC03] [http-nio-8001-exec-1] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]解包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:24.014 DEBUG 53605 [317BD9F4F3044E92A6A1D271ACD8376B] [http-nio-8001-exec-2] c.b.b.s.sink.controller.Sink3Controller inMessage:BizMessage(code=0, message=null, extMessage=null, traceId=f1afe72dac0842ad8912e063b7bcf593, parentTraceId=null, timestamp=1631513601741, data={\u0026quot;retryCount\u0026quot;:2,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}) [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:24.014 DEBUG 53605 [317BD9F4F3044E92A6A1D271ACD8376B] [http-nio-8001-exec-2] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]打包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:24.028 DEBUG 53605 [317BD9F4F3044E92A6A1D271ACD8376B] [http-nio-8001-exec-2] com.bizmda.bizsip.sink.Sink Sink通过Connect[sink-bean]调用服务 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:24.028 DEBUG 53605 [317BD9F4F3044E92A6A1D271ACD8376B] [http-nio-8001-exec-2] c.b.b.s.connector.SinkBeanSinkConnector 调用SinkBeanSinkConnector[com.bizmda.bizsip.sample.sink.controller.EchoServer]的process() [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:24.029 DEBUG 53605 [317BD9F4F3044E92A6A1D271ACD8376B] [http-nio-8001-exec-2] c.b.b.sample.sink.controller.EchoServer EchoServer传入消息:[\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;retryCount\u0026gt;2\u0026lt;/retryCount\u0026gt;\u0026lt;accountNo\u0026gt;003\u0026lt;/accountNo\u0026gt;\u0026lt;/root\u0026gt;] [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:24.030 DEBUG 53605 [317BD9F4F3044E92A6A1D271ACD8376B] [http-nio-8001-exec-2] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]解包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:28.083 DEBUG 53605 [A62381D250A149E8AC201E5F1BBBDE33] [http-nio-8001-exec-3] c.b.b.s.sink.controller.Sink3Controller inMessage:BizMessage(code=0, message=null, extMessage=null, traceId=f1afe72dac0842ad8912e063b7bcf593, parentTraceId=null, timestamp=1631513601741, data={\u0026quot;retryCount\u0026quot;:3,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}) [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:28.083 DEBUG 53605 [A62381D250A149E8AC201E5F1BBBDE33] [http-nio-8001-exec-3] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]打包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:28.091 DEBUG 53605 [A62381D250A149E8AC201E5F1BBBDE33] [http-nio-8001-exec-3] com.bizmda.bizsip.sink.Sink Sink通过Connect[sink-bean]调用服务 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:28.091 DEBUG 53605 [A62381D250A149E8AC201E5F1BBBDE33] [http-nio-8001-exec-3] c.b.b.s.connector.SinkBeanSinkConnector 调用SinkBeanSinkConnector[com.bizmda.bizsip.sample.sink.controller.EchoServer]的process() [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:28.091 DEBUG 53605 [A62381D250A149E8AC201E5F1BBBDE33] [http-nio-8001-exec-3] c.b.b.sample.sink.controller.EchoServer EchoServer传入消息:[\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;retryCount\u0026gt;3\u0026lt;/retryCount\u0026gt;\u0026lt;accountNo\u0026gt;003\u0026lt;/accountNo\u0026gt;\u0026lt;/root\u0026gt;] [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:28.093 DEBUG 53605 [A62381D250A149E8AC201E5F1BBBDE33] [http-nio-8001-exec-3] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]解包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:36.162 DEBUG 53605 [305FB08B640B41EC92EF8AED3AE667F6] [http-nio-8001-exec-4] c.b.b.s.sink.controller.Sink3Controller inMessage:BizMessage(code=0, message=null, extMessage=null, traceId=f1afe72dac0842ad8912e063b7bcf593, parentTraceId=null, timestamp=1631513601741, data={\u0026quot;retryCount\u0026quot;:4,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}) [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:36.162 DEBUG 53605 [305FB08B640B41EC92EF8AED3AE667F6] [http-nio-8001-exec-4] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]打包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:36.167 DEBUG 53605 [305FB08B640B41EC92EF8AED3AE667F6] [http-nio-8001-exec-4] com.bizmda.bizsip.sink.Sink Sink通过Connect[sink-bean]调用服务 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:36.167 DEBUG 53605 [305FB08B640B41EC92EF8AED3AE667F6] [http-nio-8001-exec-4] c.b.b.s.connector.SinkBeanSinkConnector 调用SinkBeanSinkConnector[com.bizmda.bizsip.sample.sink.controller.EchoServer]的process() [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:36.167 DEBUG 53605 [305FB08B640B41EC92EF8AED3AE667F6] [http-nio-8001-exec-4] c.b.b.sample.sink.controller.EchoServer EchoServer传入消息:[\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;retryCount\u0026gt;4\u0026lt;/retryCount\u0026gt;\u0026lt;accountNo\u0026gt;003\u0026lt;/accountNo\u0026gt;\u0026lt;/root\u0026gt;] [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:36.168 DEBUG 53605 [305FB08B640B41EC92EF8AED3AE667F6] [http-nio-8001-exec-4] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]解包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:52.373 DEBUG 53605 [933B128B00DB4B4AB79EE69CD2C80009] [http-nio-8001-exec-5] c.b.b.s.sink.controller.Sink3Controller inMessage:BizMessage(code=0, message=null, extMessage=null, traceId=f1afe72dac0842ad8912e063b7bcf593, parentTraceId=null, timestamp=1631513601741, data={\u0026quot;retryCount\u0026quot;:5,\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}) [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:52.375 DEBUG 53605 [933B128B00DB4B4AB79EE69CD2C80009] [http-nio-8001-exec-5] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]打包 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:52.379 DEBUG 53605 [933B128B00DB4B4AB79EE69CD2C80009] [http-nio-8001-exec-5] com.bizmda.bizsip.sink.Sink Sink通过Connect[sink-bean]调用服务 [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:52.379 DEBUG 53605 [933B128B00DB4B4AB79EE69CD2C80009] [http-nio-8001-exec-5] c.b.b.s.connector.SinkBeanSinkConnector 调用SinkBeanSinkConnector[com.bizmda.bizsip.sample.sink.controller.EchoServer]的process() [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:52.379 DEBUG 53605 [933B128B00DB4B4AB79EE69CD2C80009] [http-nio-8001-exec-5] c.b.b.sample.sink.controller.EchoServer EchoServer传入消息:[\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;retryCount\u0026gt;5\u0026lt;/retryCount\u0026gt;\u0026lt;accountNo\u0026gt;003\u0026lt;/accountNo\u0026gt;\u0026lt;/root\u0026gt;] [bizsip-sample-sink:192.168.10.15:8001] 2021-09-13 14:13:52.380 DEBUG 53605 [933B128B00DB4B4AB79EE69CD2C80009] [http-nio-8001-exec-5] com.bizmda.bizsip.sink.Sink Sink调用Convert[simple-xml]解包  16 Java聚合服务实现简单服务转发 通过Biz-SIP的开放API接口，通过Java开发的聚合服务，来调用CRM服务（用CrmServer.java类作为模拟），查询返回对应的账户名称。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:sample1.service1\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;31cd857883974c8bae79ecf8ac12fdf0\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1610246650385, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; } }  17 Java聚合服务调用基于Script的延迟服务 通过Biz-SIP的开放API接口，通过Java开发的聚合服务，调用SAF服务，对server3服务进行多达5次的服务重试调用。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/sample/service2\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: null, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;7df1a4f93098402b902ba8eafec7bfcb\u0026quot;, \u0026quot;parentTraceId\u0026quot;: \u0026quot;c4a603917bb04bbc97d8041015dbe36c\u0026quot;, \u0026quot;timestamp\u0026quot;: 1610247196000, \u0026quot;data\u0026quot;: { \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; } }  18 调用Netty长连接异步返回 通过Biz-SIP的开放API接口，通过RabbitMQ连接器，调用Netty TCP长连接，并把原包通过TCP长连接异步返回。 在终端1启动：\n$ nc -l 4444|nc localhost 4445  在终端2启动：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server9\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;62001818\u0026quot;,\u0026quot;sex\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;email\u0026quot;:\u0026quot;123232@163.com\u0026quot;,\u0026quot;mobile\u0026quot;:\u0026quot;18601872345\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;e40c37b3196044b5a9f5b5e9c699262d\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1621303728434, \u0026quot;data\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;mobile\u0026quot;: \u0026quot;18601872345\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;62001818\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;123232@163.com\u0026quot; } }  19 调用SpringBean服务 通过Biz-SIP的开放API接口，调用Spring容器Bean服务（用EchoBeanServer.java类作为模拟）。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/openapi/server10\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;f30a96f6d73b4f44853b56a29688e1aa\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1609914563646, \u0026quot;data\u0026quot;: { \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; } }  20 聚合服务调用SinkClient接口服务 通过Biz-SIP的开放API接口，调用以Java接口方式暴露的SinkClient服务。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/sample/service3\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;8490e767f25d4a08ad059a5ed49cec1d\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631442018752, \u0026quot;data\u0026quot;: { \u0026quot;customerDTO\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;isMarried\u0026quot;: false, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;age\u0026quot;: 20 }, \u0026quot;accountDTOs\u0026quot;: [ { \u0026quot;balance\u0026quot;: 1200, \u0026quot;account\u0026quot;: \u0026quot;0001\u0026quot; }, { \u0026quot;balance\u0026quot;: 45000, \u0026quot;account\u0026quot;: \u0026quot;0003\u0026quot; } ], \u0026quot;sink1\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; }, \u0026quot;accountDTOList\u0026quot;: [ { \u0026quot;balance\u0026quot;: 3400, \u0026quot;account\u0026quot;: \u0026quot;0002\u0026quot; }, { \u0026quot;balance\u0026quot;: 77800, \u0026quot;account\u0026quot;: \u0026quot;0004\u0026quot; } ], \u0026quot;result1\u0026quot;: \u0026quot;doService1() result\u0026quot; } }  21 Java聚合服务调用Java延迟服务 通过Biz-SIP的开放API接口，在脚本服务中调用SAF服务，对server3服务进行多达5次的服务重试调用。 上送请求数据说明：\n “maxRetryNum”为最大请求次数 “result”为最后的响应为成功还是失败。  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/sample/service4\u0026quot; -X POST --data '{\u0026quot;maxRetryNum\u0026quot;:2,\u0026quot;result\u0026quot;:\u0026quot;success\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;c16b63d02e844183811ac7cc01a4a046\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630217962113, \u0026quot;data\u0026quot;: { \u0026quot;maxRetryNum\u0026quot;: 2, \u0026quot;result\u0026quot;: \u0026quot;success\u0026quot; } }  22 聚合服务匹配SpringBean服务 通过Biz-SIP的开放API接口，通过在“prefix-service.yml”中约定的服务前缀，调用所绑定对应类（或接口）的SpringBean所对应的方法。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/springbean\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;doService1\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;003\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;a4efdb7ea392416eabd048c283535a1e\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630398028746, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: \u0026quot;doService1() result\u0026quot; } } $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/springbean\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;doService2\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;003\u0026quot;,1]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;0ac04237c79a415daa76ed6543dce839\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630398312998, \u0026quot;data\u0026quot;: {} } $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/springbean\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;queryCustomerDTO\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;003\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;d20837e2b76048f8aabb09915d691f98\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630398340509, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;isMarried\u0026quot;: false, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;age\u0026quot;: 20 } } }  23 Sink聚合服务直接调用Sink 通过Biz-SIP的开放API接口，通过配置的Sink聚合服务，直接调用CRM服务（用CrmServer.java类作为模拟），查询返回对应的账户名称。 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/sinkService\u0026quot; -X POST --data '{\u0026quot;accountNo\u0026quot;:\u0026quot;003\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;9856ede98cf2492c9d17db5e86e53752\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630474662509, \u0026quot;data\u0026quot;: { \u0026quot;accountName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;accountNo\u0026quot;: \u0026quot;003\u0026quot; } }  24 聚合服务调用DelayServiceClient接口服务 通过Biz-SIP的开放API接口，在脚本服务中调用SAF服务，对server3服务进行多达5次的服务重试调用。 上送请求数据说明：\n “maxRetryNum”为最大请求次数 “result”为最后的响应为成功还是失败。  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:/sample/service5\u0026quot; -X POST --data '{\u0026quot;method\u0026quot;:\u0026quot;notify\u0026quot;,\u0026quot;maxRetryNum\u0026quot;:3,\u0026quot;result\u0026quot;:\u0026quot;success\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: null, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;63cd38f36fa647cf9be0403c81e2c058\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630541890888, \u0026quot;data\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;notify\u0026quot;, \u0026quot;className\u0026quot;: \u0026quot;com.bizmda.bizsip.sample.sink.api.SinkInterface1\u0026quot;, \u0026quot;params\u0026quot;: [ 3, \u0026quot;success\u0026quot; ] } } ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"0ee9398b95a815a0d2d06007e5f6e1c7","permalink":"http://bizsip.bizmda.com/doc/quick-start/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/quick-start/","section":"doc","summary":"快速安装并运行Biz-SIP中间件，并运行相关的测试案例.\n","tags":null,"title":"快速启动","type":"book"},{"authors":null,"categories":null,"content":"Biz-SIP中间件通过配置来构建系统的介绍。\n一、概述 Biz-SIP中间件在开发应用时，主要涉及配置文件编写和Java代码开发，系统架构如下所示： 上图中蓝色虚框所呈现的部分，就主要是Biz-SIP中间件的配置文件。 Biz-SIP中间件的配置文件，一般都统一存放在配置目录下（由application.yml文件中的bizsip.config-path配置项所约定)，配置目录中的文件如下例所示：\nconfig |____sink.yml |____source.yml |____service.yml |____converter | |____server3 | | |____woman.vm | | |____error.vm | | |____man.vm |____service | |____client1 | | |____error.script | |____openapi | | |____sample1.script | | |____sample5.script | | |____sample2.script | | |____sample4.script |____check-rule | |____client1 | | |____sample1.yaml  sink.yml：领域层sink模块的配置文件 source.yml：渠道层source模块的配置文件 service.yml：应用层app聚合服务的的配置文件（非脚本的服务） service目录：存放所有的应用层app聚合服务编排脚本 converter目录：存放消息转换器converter相关的消息格式转换配置文件 check-rule目录：存放聚合服务校验规则配置文件\n二、应用层app配置（服务编排配置） 1. service.yml 定义了所有非脚本类聚合服务的配置参数：\n   配置项 配置说明     [].bizServiceId 聚合服务ID，要全局唯一   [].type 聚合服务执行调用方式，目前支持“integrator-bean-service”、“bean-service”、“sink-service”三种方式：   1、integrator-bean-service：该类型执行继承BizServiceInterface接口的SpringBean，并调用约定的doBizService()方法。    相关参数如下：    [].className 要执行的SpringBean类名（从BizServiceInterface接口继承）   2、bean-service：该类型执行约定的SpringBean，调用的方法和参数通过消息传递过来，方法名为消息体JSON数据中的“methodName”域，参数为消息体JSON数据中的“params”域（应为JSON数组）    [].className 要执行的SpringBean类名，由用户自行定义   3、sink-service：直接把后端的sink服务，通过此接口通过聚合服务暴露出来    [].sinkId 该聚合服务所对应的sink id，此聚合服务的数据会直接透传给sink id所对应的Sink后端。    1.1 integrator-bean-service 该类型执行继承BizServiceInterface接口的SpringBean，并调用约定的doBizService()方法，配置参数如下：\n   配置项 配置说明     [].className 要执行的SpringBean类名（从BizServiceInterface接口继承）    service.yml配置例子如下：\n- bizServiceId: /sample/service4 type: integrator-bean-service className: com.bizmda.bizsip.integrator.sample.service.sample.IntegratorService4  className是服务绑定的类，这个类需要从IntegratorBeanInterface接口继承，接口如下：\npublic interface IntegratorBeanInterface { /** * 执行聚合服务 * @param message 传入的消息 * @return 返回的消息 */ public abstract BizMessage\u0026lt;JSONObject\u0026gt; doBizService(BizMessage\u0026lt;JSONObject\u0026gt; message) throws BizException; }  1.2 bean-service 该类型执行约定的SpringBean，调用的方法和参数通过消息传递过来，方法名为消息体JSON数据中的“methodName”域，参数为消息体JSON数据中的“params”域（应为JSON数组），配置参数如下：\n   配置项 配置说明     [].className 要执行的SpringBean类名，方法由开发者自由定义。    service.yml配置例子如下：\n- bizServiceId: /springbean type: bean-service className: com.bizmda.bizsip.integrator.sample.service.sample.SinkClientInterface1Impl  className是服务绑定的类，这个类的接口需要由开发者约定Interface并实现。\n1.3 sink-service sink-server是直接把后端的sink服务，通过此接口通过聚合服务暴露出来。\n   配置项 配置说明     [].sinkId 该聚合服务所对应的sink id，此聚合服务的数据会直接透传给sink id所对应的Sink后端。    service.yml配置例子如下：\n- bizServiceId: /sinkService type: sink-service sinkId: sink1  2. service目录 service目录位置配置文件根目录下的/service目录，目录下存放了聚合服务脚本，聚合服务ID为“目录+文件前缀”的方案，例如“service/openapi/sample1.script”文件，对应的聚合服务ID为“openapi/sample1”，文件的后续名表示是支持不同的服务聚合器类型，目前仅支持script服务聚合器（*.script）。\nconfig |____sink.yml |____source.yml |____converter |____service | |____client1 | | |____error.script | |____openapi | | |____sample1.script | | |____sample5.script | | |____sample2.script | | |____sample4.script  3. Script服务聚合器脚本（*.script） Script服务整合器是构建在magic-script脚本解析器基础上的服务编排引擎，通过解释执行service目录下的*.script文件，实现内外部服务整合和编排运行。 service目录下所有的“*.script”文件，都是Script服务整合器脚本。脚本语言采用magic-script（https://gitee.com/ssssssss-team/magic-script），这是一款基于JVM的脚本语言。 在Script服务整合器脚本中，主要使用的特殊对象包括：sip对象、log对象等。\n3.1 sip对象  sip.callSink(sinkId,inData)\n 执行适配器服务调用 参数：\n sinkId：Sink ID，在sink.yml配置文件中约定。 inData：传送给服务端的数据  返回：\n 服务端返回的数据，是BizMessage内部消息类型。   sip.doDelayService(serviceId,inData,delayMilliseconds1,delayMilliseconds2\u0026hellip;)  执行SAF服务调用 参数：\n serviceId：SAF服务ID，为配置在config/script中的服务脚本。 inData：传送给服务的数据，在脚本中以“bizmessage”进行存取。 delayMilliseconds\u0026hellip;：延迟毫秒数，可以有多个，分别代表第1次、第2次\u0026hellip;..的服务延迟毫秒数  返回：\n SAF子交易的BizMessage内部消息类型。   sip.getServiceRetryCount()  获取SAF服务的当前重试次数 参数：\n （无）  返回：\n SAF服务的当前重试次数   sip.saveAsyncContext(transactionKey,context,timeout)  保存异步服务上下文 参数：\n transactionKey：异步回调的全局唯一交易索引键 context：注入回调聚合服务的上下文变量 timeout：异步服务超时时间，单位（秒）  返回：\n （无）   sip.loadAsyncContext(transactionKey)  保存异步服务上下文 参数：\n transactionKey：异步回调的全局唯一交易索引键  返回：\n 异步服务上下文  3.2 log对象 // 使用方法与SLF4J完全一致 log.info('Hello'); log.info('Hello {}','MagicAPI'); log.debug('test');  3.3 db对象  select   入参：sql:String 返回值：List\u0026lt;Map\u0026lt;String,Object\u0026gt;\u0026gt; 函数说明：查询List结果  return db.select('select * from sys_user');   selectInt   入参：sql:String 返回值：Integer 函数说明：查询int结果  //需要保证结果返回一行一列 return db.selectInt('select count(*) from sys_user');   selectOne   入参：sql:String 返回值：Map\u0026lt;String,Object\u0026gt; 函数说明：查询单个对象  return db.selectOne('select * from sys_user limit 1');   selectValue   入参：sql:String 返回值：Object 函数说明：查询单个值  //需要保证结果返回一行一列 return db.selectValue('select user_name from sys_user limit 1');   page   入参：sql:String 入参：limit : long 可省略 入参：offset : long 可省略 返回值：Object 默认返回为Object，如果自定义了分页结果，则返回自定义结果 函数说明：分页查询  //需要保证结果返回一行一列 return db.page('select * from sys_user');   update   入参：sql:String 返回值：Integer 函数说明：执行增删改操作  return db.update('delete from sys_user');   cache   入参：cacheName:String 入参：ttl:long 缓存有效期，单位毫秒，可省略，默认为配置的值 返回值：db //返回当前实例，即可以链式调用 函数说明：使用缓存  //使用缓存名为user的查询 return db.cache('user').select('select * from sys_user');   transaction   入参：callback:Function，回调函数，可省略 返回值：Object 函数说明：开启事务 自动事务  var val = db.transaction(()=\u0026gt;{ var v1 = db.update('...'); var v2 = db.update('....'); return v2; }); return val;   手动开启事务  var tx = db.transaction(); //开启事务 try{ var value = db.update('...'); db.commit(); // 提交事务 return value; }catch(e){ db.rollback(); // 回滚事务 }  3.4 redis对象 var data = bizmessage.data; var value = data.accountNo; //通过redis.命令名(命令参数,命令参数,.....,命令参数) 进行调用，其中命令名不区分大小写 redis.set('key',value); //调用set命令 //redis.setex('key',10,value); //调用setex命令 data.accountName = redis.get('key'); //调用get命令 return data;  三、适配层source配置（服务接入配置） source.yml定义了客户端适配器的配置参数，并不是所有适配层的接入模块都需要在source.yml中定义，只有用到可配置的消息转换器converter时，才需要定义：\n   配置项 配置说明     [].id 客户端的ID，要全局唯一   [].converter 参见：消息处理器配置   [].service 聚合服务相关配置   [].service-rules[] 聚合服务定位断言规则   [].service-rules[].predicate 断言规则，返回true选择当前规则rule作为聚合服务ID，空条件为true，支持EL表达式   [].service-rules[].rule 当前断言规则对应的聚合服务ID，支持EL表达式    例子：\n- id: source1 converter: type: simple-json service: service-rules: - predicate: '#{#data[serviceId] != null}' rule: '#{#data[serviceId]}' - predicate: rule: source1/error  四、领域层sink配置（服务调用配置） sink.yml定义了所有接入的服务端适配器的配置参数：\n   配置项 配置说明     [].id 服务端的ID，要全局唯一   [].type 服务端适配器调用方式，目前只支持“rest”，为RESTful方式调用   [].url 服务端适配器调用方式为“rest”方式时，该属性约定RESTful调用的url地址   [].converter 参见：消息处理器配置   [].connector 服务端协议处理器相关配置   [].connector.type 约定服务端协议处理器的类型（具体参见服务端协议处理器配置）   [].connector.* 约定服务端协议处理器的其它参数（具体参见服务端协议处理器配置）    例子：\n- id: sink1 type: rest url: http://bizsip-sample-sink/sink1 converter: type: simple-json connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.CrmServer - id: sink2 type: rest url: http://bizsip-sample-sink/sink2 converter: type: simple-json connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.ActServer  五、适配层source/领域层sink converter配置（消息适配） 1 source.yml/sink.yml source.yml和sink.yml文件中定义了消息转换器相关配置：\n   配置项 配置说明     [].converter Source模块/Sink模块的消息格式相关配置   [].converter.type Source模块/Sink模块的消息转换类型，目前支持：simple-json、simple-xml、velocity-json、velocity-xml、fixed-length、velocity-split等   [].converter.pack-rules[]（可选） 消息打包规则，选择打包格式文件   [].converter.pack-rules[].predicate 断言规则，返回true选择当前规则rule作为打包格式文件，空条件为true，支持EL表达式   [].converter.pack-rules[].rule 消息格式文件，支持EL表达式   [].converter.unpack-rules[]（可选） 消息解包规则   [].converter.unpack-rules[].predicate 断言规则（同上）   [].converter.unpack-rules[].rule 消息格式文件（同上）    消息转换类型，目前支持simple-json、simple-xml、velocity-json、velocity-xml、fixed-length、velocity-split、iso-8583等7种方式，这7种消息转换类型的说明和针对打包、解包规则说明如下：\n   消息转换类型 消息转换说明 消息转换描述 消息打包规则 消息解包规则     simple-json 支持快速简单的JSON报文适配 打包：直接输出内部标准JSON报文     解包：直接对传入JSON进行解包 无 无     simple-xml 支持快速简单的XML报文适配 打包：直接把内部标准JSON报文转换成XML格式输出     解包：对传入XML直接解包成内部标准JSON报文 无 无     velocity-json 支持基于Velocity模板的JSON报文适配 打包：根据断言规则定位的Velocity模板文件进行打包     解包：直接对传入JSON进行解包 有 无     velocity-xml 支持基于Velocity模板的XML报文适配 打包：根据断言规则定位的Velocity模板文件，进行打包     解包：对传入XML直接解包成内部标准JSON报文 有 无     fixed-length 支持基于配置的定长报文适配 打包：根据断言规则定位的打包文件，文件是基于域级打包配置参数定制的     解包：基于预解包域级配置，并根据断言规则 定位的解包文件，文件是基于域级配置参数配置的 有 有     velocity-split 支持基于配置和Velocity模板的有分隔符报文适配 打包：根据断言规则定位的Velocity模板文件进行打包     解包：基于多级分隔符配置的解包 有 无     iso-8583 支持基于配置的ISO8583报文适配 打包：根据sink.yml中的fields、destination-id、source-id配置进行打包；     解包：根据sink.yml中的fields配置进行解包 无 无      2 converter目录 “config/converter”目录，存放了各种消息的格式转换配置文件，目前支持的文件类型有“.vm”和“.yml”。 对于消息格式转换类型有打包和解包规则 的，会根据断言规则定位，到message目录下用对应的文件来加载对应的格式转换配置，如下例所示：\nconfig/converter ├── server3 │ ├── error.vm │ ├── man.vm │ └── woman.vm ├── server4 │ ├── man.yml │ └── woman.yml └── server5 ├── error.vm ├── man.vm └── woman.vm  文件类型和消息转换类型的关系如下：\n *.vm：Velocity模板文件  velocity-json消息转换类型中的打包模板 velocity-xml消息转换类型中的打包模板 velocity-split消息转换类型中的打包模板   *.yml：YML配置文件  fix-length消息转换类型中的打包和解包参数配置文件    2.1 velocity-json/velocity-xml（*.vm） 对于消息转换类型为velocity-json、velocity-xml的，会根据断言规则定位，到converter目录下用对应的vm文件进行消息打包，如下例所示：\nconfig |____converter | |____sink4 | | |____woman.vm | | |____error.vm | | |____man.vm  vm文件支持velocity模板语言进行处理，模板中注入变量有：\n   变量名 变量说明     data BizMessage.data：内部标准消息的数据体，为JSONObject对象格式    2.2 fixed-length(*.yml） 对于消息转换类型为fixed-length，会根据断言规则 定位，到converter目录下用对应的yml文件进行打包和解包，如下例所示：\nconfig |____converter | |____sink6 | | |____woman.yml | | |____error.yml | | |____man.yml  yml配置文件如下例所示：\n- name: sex length: 1 - name: accountNo length: 8 unpack-functions: - name: trim - name: accountName length: 10 unpack-functions: - name: trim - name: balance length: 10 pack-functions: - name: decimalFormat args: - \u0026quot;###,###.00\u0026quot;  相关配置域属性如下：\n   配置域 域说明     name 对应内部标准消息格式中的JSON域名。   length 域值所占长度   unpack-functions 解包函数，支持多个函数，多个函数会按序执行。   pack-functions 打包函数，同样支持多个函数    3 Converter介绍 3.1 simple-json（简单JSON格式适配） 支持快速、简单的JSON消息适配，直接把Biz-SIP内部标准消息，直接打包成外部的JSON格式；同时也直接把外部的JSON格式消息，快速直接解包成Biz-SIP内部标准消息。 可以在客户端适配器和服务端适配器中启用，配置如下例所示：\n- id: sink1 type: rest url: http://bizsip-sample-sink/sink1 converter: type: simple-json connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.CrmServer  3.2 simple-xml（简单XML格式适配） 支持快速、简单的XML消息适配，直接把Biz-SIP内部标准消息，直接打包成外部的XML格式；同时也直接把外部的XML格式消息，快速直接解包成Biz-SIP内部标准消息。 可以在客户端适配器和服务端适配器中启用，配置如下例所示：\n- id: server3 type: rest url: http://sip-sample-server/server3 converter: type: simple-xml connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.EchoServer  3.3 velocity-json（基于模板的JSON格式适配） 支持基于Velocity模板的JSON报文适配，在对外部的JSON报文打包，是采用Velocity模板文件，这个文件是通过打包断言规则来进行匹配的；外部JSON报文的解包，是直接解包成Biz-SIP内部标准消息的。 配置如下例所示，含有pack-rules：\n- id: server4 type: rest url: http://sip-sample-server/server4 converter: type: velocity-json pack-rules: - predicate: '#{#data[sex]==\u0026quot;0\u0026quot;}' rule: server3/woman.vm - predicate: '#{#data[sex]==\u0026quot;1\u0026quot;}' rule: server3/man.vm - predicate: rule: server3/error.vm connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.EchoServer  Velocity模板中注入变量有：\n   变量名 变量说明     data BizMessage.data：内部标准消息的数据体，为JSONObject对象格式    3.4 velocity-xml（基于模板的XML适配） 支持基于Velocity模板的XML报文适配，在对外部的XML报文打包，是采用Velocity模板文件，这个文件是通过打包断言规则来进行匹配的；外部XML报文的解包，是直接解包成Biz-SIP内部标准消息的。 配置如下例所示，含有pack-rules：\n- id: server5 type: rest url: http://sip-sample-server/server5 converter: type: velocity-xml pack-rules: - predicate: '#{#data[sex]==\u0026quot;0\u0026quot;}' rule: server3/woman.vm - predicate: '#{#data[sex]==\u0026quot;1\u0026quot;}' rule: server3/man.vm - predicate: rule: server3/error.vm unpack-rules: connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.EchoServer  Velocity模板中注入变量有：\n   变量名 变量说明     data BizMessage.data：内部标准消息的数据体，为JSONObject对象格式    3.5 fixed-length（定长消息适配） 支持基于配置的定长报文适配：\n 打包：根据断言规则定位的打包文件，文件是基于域级打包配置参数定制的 解包：先基于域级配置进行消息报文的预解包，并根据断言规则 定位的解包文件，文件是基于域级配置参数配置的。  配置如下例所示，含有pre-unpack、pack-rules和unpack-rules：\n- id: server6 type: rest url: http://sip-sample-server/server6 converter: type: fixed-length pre-unpack: - name: sex length: 1 functions: - name: trim pack-rules: - predicate: '#{#data[sex]==\u0026quot;0\u0026quot;}' rule: server4/woman.yml - predicate: '#{#data[sex]==\u0026quot;1\u0026quot;}' rule: server4/man.yml - predicate: rule: server4/error.yml unpack-rules: - predicate: '#{#data[sex]==\u0026quot;0\u0026quot;}' rule: server4/woman.yml - predicate: '#{#data[sex]==\u0026quot;1\u0026quot;}' rule: server4/man.yml - predicate: rule: server4/error.yml connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.EchoServer  根据解包和打包断言规则，定位报文对应的解包或打包定义yml定义文件，解包和打包定义文件如下例所示：\n- name: sex length: 1 - name: accountNo length: 8 unpack-functions: - name: trim - name: accountName length: 10 unpack-functions: - name: trim - name: balance length: 10 pack-functions: - name: decimalFormat args: - \u0026quot;###,###.00\u0026quot;  主要的配置定义如下：\n   配置项 配置说明     [].name 域名，对应Biz-SIP内部标准消息中的域名。   解包：表示当前数据从些域名中取得数据；    打包：表示数据对置入该域名对应的数据域。    [].length 当前域的长度   [].unpack-functions[]（可选） 解包时，对当前域域值进行处理的域处理函数。   [].pack-functions[]（可选） 打包时，对当前域域值进行处理的域处理函数。    其中，unpack-functions、pack-functions，以及pre-unpack项下的functions，都是域处理函数，具体请参见“6.4 域处理函数”一节，相关配置定义如下：\n   配置项 配置说明     name 域处理函数，具体请参见域处理函数一节   args[] 域处理函数的参数，具体参数约定请参见域处理函数一节。    fixed-length格式转换的解包流程为：\n 根据“pre-unpack”中的设置，首先对传入的定长消息进行预解包，先解出关键域的域值； 根据“unpack-rule”，用上一步解出的关键域域值，根据解包断言规则，选择指定的解包yml定义文件； 根据上一步选择的解包yml定义文件，对传入的定长消息进行解包，解包成Biz-SIP内部标准消息。  打包流程为：\n 根据“pack-rule”，根据打包断言规则，选择指定的打包yml定义文件； 根据上一步选择的打包yml定义文件，对Biz-SIP内部标准消息进行打包，打包成定长消息报文。  3.6 velocity-split（基于模板的有分隔符消息适配） velocity-split消息适配，是针对有分隔符消息的转换和适配，打包是基于Velocity模板方式来进行转换的，解包是基于客户端适配器和服务端适配器的消息配置来转换的。 velocity-split消息适配的打包，是支持基于Velocity模板的适配，模板文件是通过打包断言规则来进行匹配的。 source.yml/sink.yml文件的配置如下例所示，含有separators和pack-rules的定义：\n- id: server7 type: rest url: http://sip-sample-server/server7 converter: type: velocity-split separators: - \u0026quot;*\u0026quot; - \u0026quot;,\u0026quot; pack-rules: - predicate: '#{#data[sex]==\u0026quot;0\u0026quot;}' rule: server5/woman.vm - predicate: '#{#data[sex]==\u0026quot;1\u0026quot;}' rule: server5/man.vm - predicate: rule: server5/error.vm connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.EchoServer  主要的配置定义如下：\n   配置项 配置说明     [].converter.separators    约定分隔符，可以设置多个分隔符。     velocity-split格式转换的打包流程为：\n 根据“pack-rule”，执行打包断言规则，选择指定的打包vm定义文件； 根据上一步选择的解包yml定义文件，对Biz-SIP内部标准消息进行打包，打包成有分隔符消息报文。  解包流程为：\n 根据“unpack-rule”，根据打包断言规则，选择指定的打包yml定义文件； 根据source.yml/sink.yml文件中的separators设置，将有分隔符消息报文，直接解包到Biz-SIP内部标准消息报文。  3.7 iso-8583（ISO8583消息适配） 支持基于配置的ISO8583消息适配，打包和解包，都是根据sink.yml文件中对应sink的iso-8583报文和域配置信息，进行ISO8583报文的打包和解包。 sink.yml对应ISO8583报文配置，如下例所示：\n- id: sink13 type: rest url: http://bizsip-sample-sink/sink13 converter: type: iso-8583 destination-id: '00010344' source-id: '42430440' fields: - index: 2 length: 19 unfixed: 2 name: accNo2 - index: 3 length: 6 name: processingCode3 - index: 4 length: 12 name: amt_trans4 - index: 5 length: 12 name: amt_settlmt5 - index: 6 length: 12 name: transactionAmount6 - index: 7 length: 10 name: transmsn_date_time7 - index: 9 length: 8 name: transmsn_date_time9 - index: 10 length: 8 name: transmsn_date_time10 - index: 11 length: 6 name: systemTraceAuditNumber11 - index: 12 length: 6 name: time_local_trans12 - index: 13 length: 4 name: date_local_trans13 - index: 14 length: 4 name: date_expr14 - index: 15 length: 4 name: date_settlmt15 - index: 16 length: 4 name: date_conv16 - index: 18 length: 4 name: mchnt_type18 - index: 19 length: 3 name: mchnt_cntry_code19 - index: 22 length: 3 name: pos_entry_mode_code22 - index: 23 length: 3 name: card_seq_num23 - index: 25 length: 2 name: pos_cond_code25 - index: 26 length: 2 name: pos_pin_cap_code26 - index: 28 length: 9 name: amt_fee28 - index: 32 length: 11 unfixed: 2 name: acq_inst_id_code32 - index: 33 length: 11 unfixed: 2 name: fwd_inst_id_code33 - index: 35 length: 37 unfixed: 2 name: track2_data35 - index: 36 length: 104 unfixed: 3 name: track3_data36 - index: 37 length: 12 name: retrivl_ref_num37 - index: 38 length: 6 name: authr_id_resp38 - index: 39 length: 2 name: resp_code39 - index: 41 length: 8 name: card_accptr_termnl_id41 - index: 42 length: 15 name: card_accptr_id42 - index: 43 length: 40 name: card_accptr_name_loc43 - index: 44 length: 25 unfixed: 2 name: addtnl_resp_code44 - index: 45 length: 76 unfixed: 2 name: track1_data45 - index: 48 length: 512 unfixed: 3 name: addtnl_data_private48 - index: 49 length: 3 name: currcy_code_trans49 - index: 50 length: 3 name: currcy_code_settlmt50 - index: 51 length: 3 name: currcy_code_cdhldr_bil51 - index: 52 length: 8 name: pin_data52 - index: 53 length: 16 name: security_control_info53 - index: 54 length: 40 unfixed: 3 name: addtnl_amt54 - index: 55 length: 255 unfixed: 3 name: ICC_data55 - index: 56 length: 255 unfixed: 3 name: token_par56 - index: 57 length: 100 unfixed: 3 name: issr_addtnl_data57 - index: 59 length: 600 unfixed: 3 name: detai_inquiring59 - index: 60 length: 100 unfixed: 3 name: reserved60 - index: 61 length: 200 unfixed: 3 name: ch_auth_info61 - index: 62 length: 200 unfixed: 3 name: switching_data62 - index: 63 length: 512 unfixed: 3 name: fin_net_data63 - index: 70 length: 3 name: net_mgr_info_code70 - index: 90 length: 42 name: ori_data_element90 - index: 96 length: 8 name: msg_security_code96 - index: 100 length: 11 unfixed: 2 name: rcvg_inst_id_code100 - index: 102 length: 28 unfixed: 2 name: acct_id_1_102 - index: 103 length: 28 unfixed: 2 name: acct_id_2_103 - index: 104 length: 512 unfixed: 3 name: trans_industry_app_inf104 - index: 113 length: 512 unfixed: 3 name: add_data113 - index: 117 length: 256 unfixed: 3 name: addtnl_data117 - index: 121 length: 100 unfixed: 3 name: national_sw_resved121 - index: 122 length: 100 unfixed: 3 name: acq_inst_resvd122 - index: 123 length: 100 unfixed: 3 name: issr_inst_resvd123 - index: 125 length: 256 unfixed: 3 name: addtnl_data125 - index: 128 length: 8 name: msg_authn_code128 connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.EchoServer  主要的配置定义如下：\n   配置项 配置说明     [].type 约定为“iso-8583”   [].destination-id 配置ISO8583报文中的目的ID   [].source-id 配置ISO8583报文中的源ID   [].fields ISO8583中各域的配置   [].fields[].index 对应ISO8583报文中的域索引号。   0：报文头，缺省域名为“msgHead”    1：报文类型标识，缺省域名为“msgType”    2\u0026hellip;128：ISO8583域    [].fields[].name 域名，主要在生成的JSON报文中用，报文头、报文类型标识缺省为msgHead、msgType，2\u0026hellip;128域缺省为f2\u0026hellip;f128   [].fields[].length 域长度，可变长度域为最大域长度   [].fields[].unfixed 可变长度域类型，可以取值为2和3，代表长度位分别是2位和3位；如果不配置则为定长域。    4 域处理函数 域处理函数可以用在以下几个地方：\n 预解包：一般定义在source.yml/sink.yml文件中的pre-unpack设置下的functions； 解包：一般定义在解包yml文件中的unpack-functions； 打包：一般定义在打包yml文件中的pack-functions。  支持的域处理函数如下（可以自行扩展）：\n   域处理函数名 说明 参数     fill 填充 参数1（必选）：填充方式，left/right分别代表左填充和右填充   参数2（必选）：填充字符     参数3（可选）：填充长度，缺省为当前域长度     trim 去除空格 参数1（可选）：left/right分别代表去左边空格和去右边空格，缺省为左右空格都去掉。   decimalFormat 对数字进行格式化 参数1（必选）：根据Java中的DecimalFormat类格式，对数字进行格式化    六、领域层sink connector配置（通讯适配） 1 Sink-Bean Connector 相关配置参数：\n   配置项 配置说明     [].connector.type 约定为“sink-bean”   [].connector.class-name 约定调用的java类   [].connector.spring-bean 约定是否调用的是Spring容器Bean（缺省是非Spring容器Bean）    例子：\n- id: server1 type: rest url: http://sip-sample-server/server1 converter: type: simple-json connector: type: sink-bean class-name: com.bizmda.bizsip.sample.sink.controller.CrmServer  Sink-Bean Connector相关类，需要从以下接口来继续实现，一般开发人员会根据传入的参数，选择继承不同的接口：\n 采用Biz-SIP标准的JSONObject来做入参、出参，一般是开发纯粹做交易处理的模块，可以开发并实现JSONObjectSinkBeanInterface接口的类，并挂接到Sink-Bean Connector上，JSONObjectSinkBeanInterface接口约定如下：  public interface JSONObjectSinkBeanInterface { /** * JSONObject SinkBean服务调用接口 * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public JSONObject process(JSONObject packMessage) throws BizException; }   采用字节流byte[]来做入参、出参，一般是涉及到不同消息类型的转换，可以开发并实现SinkBeanInterface接口的类，并挂接到Sink-Bean Connector上，SinkBeanInterface接口约定如下：  public interface SinkBeanInterface { /** * Java服务调用接口 * @param beforeJsonObject 打包前的JsonObject * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public byte[] process(JSONObject beforeJsonObject, byte[] packMessage) throws BizException; }  另外，如果要在process()前后，以及异常时做些个性化的开发切面，可以再加上SinkBeanAspectInterface接口的实现：\npublic interface SinkBeanAspectInterface { /** * * @param jsonObject 一般为convertor处理前传入的JSONObject * @return 经过处理后的JSONObject */ public JSONObject beforeProcess(JSONObject jsonObject); /** * * @param beforeJsonObject 一般为convertor处理前传入的JSONObject * @param afterJsonObject 经过process()处理后返回的JSONObject * @return */ public JSONObject afterProcess(JSONObject beforeJsonObject,JSONObject afterJsonObject); /** * * @param jsonObject 传入process()的JSONObject * @param bizException 在process()中抛出的异常 */ public void handleProcessException(JSONObject jsonObject,BizException bizException); }  2 Bean Connector Bean Connector能根据sink.yaml和传入数据中包含的约定参数，调用约定的Java类名方法名。 在服务编排脚本中，是通过传入JSON数据中的className、methodName、params，来分别约定调用的Java类外、方法名、参数列表，如果在sink.yml中配置了className和methodName，则以sink.yml中的配置为准，如下例：\nvar data = { methodName: \u0026quot;getCustomerList\u0026quot; }; var result = sip.callSink(\u0026quot;sink11\u0026quot;,data); data = { methodName: \u0026quot;saveCustomerDto\u0026quot;, params: [\u0026quot;004\u0026quot;,\u0026quot;赵六\u0026quot;] }; var result = sip.callSink(\u0026quot;sink11\u0026quot;,data); data = { methodName: \u0026quot;getName\u0026quot;, params: \u0026quot;005\u0026quot; }; var result = sip.callSink(\u0026quot;sink11\u0026quot;,data); data = { methodName: \u0026quot;getAge\u0026quot;, params: \u0026quot;005\u0026quot; }; var result = sip.callSink(\u0026quot;sink11\u0026quot;,data); return result;  这里有二点需要注意：\n 所对应的Sink，要求配置的converter一定是“simple-json”类型，其它类型的converter不支持。 调用Sink后返回的结果，是用“result”作为根节点的JSON报文，如下所示：  \u0026quot;result\u0026quot;: [ { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;age\u0026quot;: 20 }, { \u0026quot;sex\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;李四\u0026quot;, \u0026quot;age\u0026quot;: 30 }, { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;王五\u0026quot;, \u0026quot;age\u0026quot;: 40 } ]  \u0026quot;result\u0026quot;: 30  对应的调用Java类，如下：\npublic class JavaApiBean { public CustomerDto[] getCustomerList() { ...... } public void saveCustomerDto(String customerId,String name) { ...... } public String getName(String id) { ...... } public int getAge(String id) { ...... } }  如果传入JSON数据中没有传入，则以sink.yaml中对应配置为准，相关配置参数：\n   配置项 配置说明     [].connector.type 约定为“bean”   [].connector.class-name 设置调用的java类（可选）   [].connector.method-name 设置调用的方法名（可选）   [].connector.spring-bean 约定是否调用的是Spring容器Bean（缺省是非Spring容器Bean）    例子：\n## 测试调用Java API的Sink - id: sink11 type: rest url: http://bizsip-sample-sink/sink11 converter: type: simple-json connector: type: bean class-name: com.bizmda.bizsip.sample.sink.javaapi.JavaApiBean method-name: getAge  3 Netty Connector 相关配置参数：\n   配置项 配置说明     [].connector.type 约定为“netty”   [].connector.host 约定调用的TCP主机地址   [].connector.port 约定调用的TCP端口地址    例子：\n- id: netty-server type: rest url: http://sip-sample-server/netty converter: type: simple-json connector: type: netty host: 127.0.0.1 port: 10002  4 RabbitMQ Connector 相关配置参数：\n   配置项 配置说明     [].connector.type 约定为“rabbitmq”   [].connector.route-key 投递消息时的Route Key    例子：\n- id: sink9 type: rest url: http://bizsip-sample-sink/sink9 converter: type: simple-json connector: type: rabbitmq route-key: sink9  七、典型Source端适配器介绍与配置 对于一些常用的服务接入模式，提供了开箱即用的Source端适配器，可以直接拿来用，也可以在原有的基础上再做个性化改造。\n1 RESTful服务接入适配器 RESTful服务接入适配器，是建立RESTful服务器来处理发来的RESTful消息，服务请求URL为“http://{地址}:{端口}/rest”，请求需要以“POST”方式来提交，适配器收到发来的消息后，会发给聚合服务整合器进行处理，并把处理结果同步返回给接入端。 客户端适配器代码放在“source/rest-source”模块中，启动运行程序为“RestSourceApplication.java”。 模块application.yml相关参数：\n   配置项 配置说明     bizsip.config-path Biz-SIP中间件配置文件根目录位置   bizsip.integrator-url 服务聚合器的开放接口url地址   bizsip.source-id 客户端适配器ID，是在source.yml文件中定义的    2 Netty TCP服务接入适配器 Netty TCP服务接入适配器，是建立一个Netty服务器来侦听指定的端口，收到发来的TCP报文后，会发给聚合服务整合器进行处理，并把处理结果同步返回给接入端，可以支持Biz-SIP所有已支持的消息报文类型。 客户端适配器代码放在“source/netty-source”模块中，启动运行程序为“NettySourceApplication.java”。 模块application.yml相关参数：\n   配置项 配置说明     bizsip.config-path Biz-SIP中间件配置文件根目录位置   bizsip.integrator-url 服务聚合器的开放接口url地址   bizsip.source-id 客户端适配器ID，是在source.yml文件中定义的   netty.port 定义Netty TCP服务的侦听端口    相关测试案例可以参见sample8。\n八、服务校验规则 Biz-SIP中间件支持服务消息域校验规则和服务阻断校验规则，服务消息域校验规则能对上送域的域值进行合法性检验，对于不符合检验规则的消息，会直接在入口处拒绝。服务阻断检验规则能对服务上送数据进行检查，对不符合规则的服务，也会在入口处拒绝，类似于服务的风控系统。 服务检验规则，是配置在config/check-rule目录下，配置文件的目录和文件名和对应的服务脚本位置应一致，配置文件后缀为“.yml”，配置相关参数：\n   配置项 配置说明     field-check-rules 定义域校验规则   field-check-rules.[].field 域的JSON取值Path，例如email、account[1].balance   field-check-rules.[].rule 域校验规则，具体参见域校验规则一节   field-check-rules.[].args[] 域检验规则的参数，具体参见域检验规则一节   field-check-rules.[].message 检验出错后，显示给调用方的错误消息。message可以嵌入域值，例如“不是邮箱地址:{}”。   field-check-mode 域检验模式，主要有“one”和“all”这二种模式，“one”表示有一个域不满足，即返回错误，返回的错误只包括第一个不满足的原因信息；“all”表示返回错误会包括所有不满足的原因信息。   service-check-rules 定义服务校验规则   service-check-rules.[].script 服务检验脚本   service-check-rules.[].message 检验出错后，显示给调用方的错误消息。   service-check-mode 服务校验模式，主要有“one”和“all”这二种模式，“one”表示有一个域不满足，即返回错误，返回的错误只包括第一个不满足的原因信息；“all”表示返回错误会包括所有不满足的原因信息。    具体案例如下： config/check-rule/openapi/sample1.yml\nfield-check-rules: - field: email rule: isEmail message: '不是邮箱地址:{}' - field: sex rule: notEmpty message: '不能为空' - field: mobile rule: isMatchRegex args: - '^[1][3,4,5,6,7,8,9][0-9]{9}$' message: '不是手机号{}' field-check-mode: one service-check-rules: - script: if(data.sex == '1') {return '性别不符合!';} message: '额度超限' service-check-mode: one  域检验规则：\n   域校验规则 说明 参数     isCitizenId 验证是否为身份证号码（支持18位、15位和港澳台的10位） （无）   isEmail 验证是否为可用邮箱地址 （无）   notEmpty 验证是否为空 （无）   isMatchRegex 通过正则表达式验证 参数1：正则表达式        ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"98a19aefb7e63d8c59abb79bcfe1c1dd","permalink":"http://bizsip.bizmda.com/doc/configuation/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/configuation/","section":"doc","summary":"Biz-SIP中间件通过配置来构建系统的介绍。\n","tags":null,"title":"系统配置","type":"book"},{"authors":null,"categories":null,"content":"介绍使用Java代码来开发基于Biz-SIP中间件的系统。\n一、应用开发指南 Biz-SIP中间件在开发应用时，主要涉及配置文件编写和Java代码开发，系统架构如下所示： 上图中蓝底黑字所呈现的部分，就是需要Java代码开发的，涉及适配层、应用层和领域层。蓝色虚箭头线所涉及的接口，就是不同层次之间需要互相依赖的接口定义。\n1. 渠道接入模块 渠道接入模块主要负责各种渠道的接入，主要功能包括：\n 渠道接入的安全处理，包括报文加解密、加签解签； 渠道接入的报文打包和解包； 渠道接入的报文校验； 渠道接入的交易处理，包括流水记录、风控处理、终端管理等； 调用应用层服务。  1.1 报文打包和解包 平台提供JSON、XML、定长、有分隔符、ISO8583的格式转换器（converter），如果采用这些平台提供的converter，就需要约定Source ID。 如果采用编码实现报文打解包，就可以不考虑Source ID的约定。\n1.2 报文校验 在应用层中，有对应用层聚合服务的校验机制，包括域级校验和服务级校验，可以考虑统一在应用层进行报文检验。 但如果是仅针对于该特定渠道的报文校验，就只能考虑在渠道接入模块做了。\n1.3 交易处理 对于简单的交易处理，可以考虑用Spring Service来做交易处理。 在编码时注意，调用应用层聚合服务可能会导致时延较长，应避免在有数据库操作的Spring Service类中调用应用层聚合服务，并在有数据库操作的Spring Service类上尽量加@Transactional，以避免长时间锁表。\n1.4 调用应用层服务 统一采用“SourceClientFactory.getBizServiceClient(Class tClass,String bizServiceId)”来调用应用层聚合服务。 对于Sink服务，在渠道接入模块不要直接调用（也无法直接调用），可以在应用层定义关联些Sink服务的sink-service，来透传调用。\n2. 第三方系统接入模块 第三方系统接入，主要包括以下几种方式：\n 同步调用第三方系统服务：标准的sink服务，在领域层进行封装sink服务。 异步调用第三方系统服务：  通知第三方系统服务：简单的就是标准的sink服务，如果涉及存储转发，则需要使用延迟服务来进行没有收到接收回执后的重发操作。 第三方系统调用我方服务：这种类型请参照上节对于渠道接入模块的介绍，这里不再展开讲。    主要涉及的功能有：\n 接收Integrator发来的服务请求； 第三方接入的安全处理，包括报文加解密、加签解签； 第三方接入的报文打包和解包； 第三方接入的交易处理，包括流水记录、风控处理等； 异步回调现场恢复 通知服务的存储转发 事务完整性保障；  2.1 接收Integrator发来的服务请求 Sink模块是通过connector接收Integrator发来的服务请求，connector主要有二种：\n bean：需要定义Interface接口类，一般在第三方渠道对接用得比较少； sink-bean：无需定义接口，根据需求也有二种类型的处理：  采用Biz-SIP标准的JSONObject来做入参、出参，一般不涉及到报文格式转换或报文格式转换由开发者自己编码完成，JSONObjectSinkBeanInterface接口约定如下：    public interface JSONObjectSinkBeanInterface { /** * JSONObject SinkBean服务调用接口 * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public JSONObject process(JSONObject packMessage) throws BizException; }   采用字节流byte[]来做入参、出参，一般是涉及到不同消息类型的转换，SinkBeanInterface接口约定如下：  public interface SinkBeanInterface { /** * Java服务调用接口 * @param beforeJsonObject 打包前的JsonObject * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public byte[] process(JSONObject beforeJsonObject, byte[] packMessage) throws BizException; }  2.2 报文打包和解包 平台提供JSON、XML、定长、有分隔符的格式转换器（converter），如果采用这些平台提供的converter，就需要Sink实现SinkBeanInterface接口，传入参数是经过converter转换后的字节流byte[]。 如果由开发者自己编码实现报文打解包，建议Sink实现JSONObjectSinkBeanInterface接口，传入参数是平台约定的JSONObject。\n2.3 交易处理 对于简单的交易处理，可以考虑用SpringBean（@Service）来做交易处理。 在编码时注意，调用第三方应用时可能会导致时延较长，应避免在有数据库操作的SpringBean类中调用第三方应用服务，并在有数据库操作的SpringBean类上尽量加@Transactional，以避免长时间锁表。 另外，在实现SinkBeanInterface或JSONObjectSinkBeanInterface接口时，同时实现SinkBeanAspectInterface切面接口，也是一种简单的做法，并在切面方法中实现交易处理逻辑，并在方法上加@Transactional，以避免长时间锁表。\npublic interface SinkBeanAspectInterface { /** * * @param jsonObject 一般为convertor处理前传入的JSONObject * @return 经过处理后的JSONObject */ public JSONObject beforeProcess(JSONObject jsonObject); /** * * @param beforeJsonObject 一般为convertor处理前传入的JSONObject * @param afterJsonObject 经过process()处理后返回的JSONObject * @return */ public JSONObject afterProcess(JSONObject beforeJsonObject,JSONObject afterJsonObject); /** * * @param jsonObject 传入process()的JSONObject * @param bizException 在process()中抛出的异常 */ public void handleProcessException(JSONObject jsonObject,BizException bizException); }  2.4 异步回调现场恢复 通过领域层sink服务传出消息，应用层服务（也称为异步调用的前半段服务）即完成；再通过渠道接入模块再回调后半段服务（一般是另一个应用层服务）,存在恢复交易现场的操作，可以调用SipService.loadAsyncContext()来实现，这和接入第三方时调用的SipService.saveAsyncContext()是相配套的。\n2.5 通知服务的存储转发 在应用层服务通过IntegratorClientFactory.getDelayBizServiceClient()发起延迟服务，实现通知服务的存储转发。\n2.6 事务完整性保障 在应用层服务通过IntegratorClientFactory.getDelayBizServiceClient()发起延迟服务，来实现补偿，包括向前补偿和向后补偿这二种方式。\n3. 交易处理模块 交易处理模块就是一种特殊的Sink模块，是通过connector接收Integrator发来的服务请求，由于交易处理模块不涉及消息格式转换，所以connector主要有二种：\n bean：需要定义Interface接口类； sink-bean：采用Biz-SIP标准的JSONObject来做入参、出参，交易处理模块需要实现JSONObjectSinkBeanInterface接口。  3.1 bean（Interface接口类交易处理） 采用bean类型connector，接口明确清晰，调用方一目了然，但需要调用双方提前约定Interface接口类。 在交易类型超过5个时，建议采用Command Executor（命令处理程序），分成多个xxxCmdExe类来进行处理，这些类应统一继承AbstractBeanCmdExe类。\n3.2 sink-bean（JSONObject出入参交易处理） 采用sink-bean类型connector，接口不用提前约定，扩展性强，但缺点也是很明显，调用双方缺乏接口约定的机制。 在交易类型超过5个时，建议采用Command Executor（命令处理程序），分成多个xxxCmdExe类来进行处理，这些类应统一继承AbstractSinkBeanCmdExe类，并统一在execute()中实现业务逻辑处理。\n4. OpenAPI接口模块 OpenAPI接口模块主要功能：\n 敏感数据加解密及报文加签验签； RESTful接口封装； OpenAPI接口文档的生成； Sandbox； 聚合服务的调用  4.1 RESTful接口封装和OpenAPI接口文档 根据接口要求开发controller类，并加上API注释，自动生成Swagger/Knife4j文档。\n4.2 聚合服务的调用 统一采用“SourceClientFactory.getBizServiceClient(Class tClass,String bizServiceId)”来调用应用层聚合服务。\n5. 应用层服务 应用层服务功能：\n 领域层服务（Sink服务）的编排 领域层服务（Sink服务）透传到适配层服务（Source服务和OpenAPI） 存储转发服务的封装 补偿交易的封装  应用层服务，主要包括以下三类服务：\n 通过sink-service透传的领域层sink服务：服务命名为”sink/xxx“，其中xxx和领域层服务xxx-sink前缀一致； 只涉及某一个sink的延迟服务：服务命名为”sink/xxx-delay/\u0026hellip;“，其中xxx和领域层服务xxx-sink前缀一致，但涉及到多个sink聚合编排的延迟服务，应直接放在相关的聚合应用服务中； 聚合应用服务：服务命名为”app/yyy/\u0026hellip;“，其中yyy是聚合应用服务名，涉及到多个sink聚合编排的延迟服务，也放在这里。  6. 项目依赖 6.1 适配层source模块 在pom.xml文件中添加source-spring-boot-starter依赖，以及应用层app模块和领域层sink模块相关联的client接口相关包：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.bizmda.bizsip\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;source-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  6.2 应用层app模块 在pom.xml文件中添加integrator-spring-boot-starter依赖，以及领域层sink模块相关联的client接口相关包：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.bizmda.bizsip\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;integrator-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  6.3 领域层sink模块 在pom.xml文件中添加sink-spring-boot-starter依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.bizmda.bizsip\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sink-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  7. 各模块application.yml配置 7.1 网关模块 Open API网关只在Spring Cloud版本中存在，在Spring Boot版本中不需要部署。 api-gateway模块中的application.yml：\n   配置项 配置说明     server.port 为api-gateway网关的侦听端口，建议用8000   spring.cloud.nacos.discovery.server-addr Nacos服务端口   spring.cloud.gateway.routes 为配置转发给Integrator服务整合器的路由断言，建议不要修改。    例子：\nserver: port: 8000 spring: application: name: bizsip-api-gaetway cloud: nacos: discovery: server-addr: bizsip-nacos:8848 gateway: discovery: locator: enabled: true lower-case-service-id: true routes: - id: bizsip-integrator uri: lb://bizsip-integrator predicates: - Path=/api/** logging: level: com.bizmda.bizsip: debug graceful: shutdown: enabled: true  7.2 适配层source模块 Source模块的application.yml中的主要相关参数：\n   配置项 配置说明     bizsip.config-path Biz-SIP中间件配置文件根目录位置   bizsip.integrator-url 服务聚合器Integrator的接口url地址    例子：\nserver: port: 8080 spring: application: name: bizsip-sample-source cloud: nacos: discovery: server-addr: bizsip-nacos:8848 # 以下配置在Istio部署中打开，以不采用NACOS注册中心，而采用etcd注册机制 # cloud: # service-registry: # auto-registration: # enabled: false #禁用注册中心服务 bizsip: config-path: /var/bizsip/config integrator-url: http://bizsip-integrator/api logging: level: com.bizmda.bizsip: debug  7.3 应用层app模块 应用层app Integrator模块中的application.yml中的主要相关参数：\n   配置项 配置说明     bizsip.config-path Biz-SIP中间件配置文件根目录位置   server.port 服务整合器（Integrator）的微服务端口，建议用8888端口，避免和其它端口相冲突   spring.cloud.nacos.discovery.server-addr Nacos服务端口   spring.datasource.* 数据库连接配置（用于服务脚本中db对象）   spring.redis.* redis连接配置（用于服务脚本中redis对象）   spring.rabbitmq.* RabbitMQ配置（用于事务管理器）    例子：\nserver: port: 8888 spring: application: name: bizsip-integrator cloud: nacos: discovery: server-addr: bizsip-nacos:8848 # 以下配置在Istio部署中打开，以不采用NACOS注册中心，而采用etcd注册机制 # cloud: # service-registry: # auto-registration: # enabled: false #禁用注册中心服务 datasource: url: jdbc:mysql://bizsip-mysql/sip username: root password: bizsip123456 driver-class-name: com.mysql.jdbc.Driver redis: redisson: enable: true host: bizsip-redis port: 6379 timeout: 6000 database: 0 lettuce: pool: max-active: 10 # 连接池最大连接数（使用负值表示没有限制）,如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽) max-idle: 8 # 连接池中的最大空闲连接 ，默认值也是8 max-wait: 100 # # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException min-idle: 2 # 连接池中的最小空闲连接 ，默认值也是0 shutdown-timeout: 100ms rabbitmq: virtual-host: / host: bizsip-rabbitmq port: 5672 username: springcloud password: springcloud listener: simple: concurrency: 5 max-concurrency: 15 prefetch: 10 bizsip: config-path: /var/bizsip/config logging: level: com.bizmda.bizsip: debug  7.4 领域层sink模块 领域层Sink应用的application.yml中的主要相关参数：\n   配置项 配置说明     bizsip.config-path Biz-SIP中间件配置文件根目录位置   bizsip.sink-id（可选） sink-spring-boot-starter中自带通用SinkController对应的sink-id参数。   只有启用SinkController才会配置该参数     SinkController为通用的Sink处理模块，能接收来自Integrator发来服务，并根据sink.yml中Sink的配置自动进行相应处理，如果没有特殊的处理需求，一般建议直接采用SinkController即可。 要启用SinkController，需要在应用启动类中，加上对应的Spring类扫描路径（\u0026ldquo;com.bizmda.bizsip.sink.controller\u0026rdquo;）​：\n@SpringBootApplication @MapperScan(\u0026quot;com.xbank.infrastructure.db.customer.mapper\u0026quot;) @ComponentScan(basePackages={\u0026quot;cn.hutool.extra.spring\u0026quot;, \u0026quot;com.bizmda.bizsip.sink.controller\u0026quot;, \u0026quot;com.xbank\u0026quot;}) @Import(cn.hutool.extra.spring.SpringUtil.class) public class CustomerSinkApplication { public static void main(String[] args) { SpringApplication.run(CustomerSinkApplication.class, args); } }  例子：\nserver: port: 8001 spring: application: name: customer-sink cloud: nacos: discovery: server-addr: bizsip-nacos:8848 datasource: url: jdbc:mysql://bizsip-mysql/xbank?autoReconnect=true username: root password: bizsip123456 driver-class-name: com.mysql.cj.jdbc.Driver bizsip: config-path: /Users/shizhengye/IdeaProjects/xbank/xbank-app/config sink-id: customer-sink logging: level: com.bizmda.bizsip: debug com.xbank: trace  8. 命名规则    用途 规范 解释     领域层服务（sink） xxx-sink    应用层服务（service） sink/xxx 通过sink-service透传到领域层的sink服务    sink/xxx-delay/\u0026hellip; 某一个sink服务相关的延迟服务，这里的延迟服务只涉及到该sink的调用，不涉及其它sink服务的调用。    app/yyy/\u0026hellip; 封装的某一应用层服务集合，包括一系列相关应用层服务，涉及到多个sink服务的延迟服务，也放在这里。   适配层服务（source） xxx-source 涉及到消息格式转换配置时，才需要配置Source ID    二、调用Sink服务和App服务 1. Source调用App服务 统一采用“SourceClientFactory.getBizServiceClient(Class tClass,String bizServiceId)”来调用应用层聚合服务（tClass必须是接口类），二种调用方式：\n 接口约定调用：由应用层定义接口调用的Interface接口类，由渠道接入模块所引用。如下例所示：  @RestController @RequestMapping(\u0026quot;/personal\u0026quot;) public class PersonalController { private PersonalAppInterface personalAppInterface = SourceClientFactory .getBizServiceClient(PersonalAppInterface.class,\u0026quot;app/personal\u0026quot;); ... @GetMapping(value =\u0026quot;/getCustomerAndAccountList\u0026quot;) public CustomerAndAccountList getCustomerAndAccountList(String customerId) { return this.personalAppInterface.getCustomerAndAccountList(customerId); } @GetMapping(value =\u0026quot;/getAccountListByCustomerId\u0026quot;) public List\u0026lt;Account\u0026gt; getAccountListByCustomerId(String customerId) { return this.personalAppInterface.getAccountListByCustomerId(customerId); } @GetMapping(value =\u0026quot;/getCustomer\u0026quot;) public Customer getCustomer(String customerId) { return this.personalAppInterface.getCustomer(customerId); } ... }   非接口约定调用：采用平台通用JSONObject类型，Interface接口类统一采用BizMessageInterface接口类，并统一用call()来调用应用层聚合服务。如下例所示：  @RestController @RequestMapping(\u0026quot;/personal\u0026quot;) public class PersonalController { private BizMessageInterface payment1SinkInterface = SourceClientFactory .getBizServiceClient(BizMessageInterface.class,\u0026quot;sink/payment1\u0026quot;); ... @GetMapping(value =\u0026quot;/send2Payment\u0026quot;) public BizMessage\u0026lt;JSONObject\u0026gt; send2Payment(String message) throws BizException { JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;message\u0026quot;,message); return this.payment1SinkInterface.call(jsonObject); } }  2. App调用Sink服务 统一采用“IntegratorClientFactory.getSinkClient(Class tClass,String sinkId)”来调用领域层Sink服务（tClass必须是接口类），有二种调用方式：\n 接口约定调用：由应用层定义接口调用的Interface接口类，由渠道接入模块所引用。如下例所示：  @Service public class PersonalAppService implements PersonalAppInterface { private AccountSinkInterface accountSinkInterface = IntegratorClientFactory .getSinkClient(AccountSinkInterface.class,\u0026quot;account-sink\u0026quot;); private CustomerSinkInterface customerSinkInterface = IntegratorClientFactory .getSinkClient(CustomerSinkInterface.class,\u0026quot;customer-sink\u0026quot;); ... @Override public CustomerAndAccountList getCustomerAndAccountList(String customerId) { Customer customer = this.customerSinkInterface.getCustomer(customerId); List\u0026lt;Account\u0026gt; accountList = this.accountSinkInterface.getAccountListByCustomerId(customerId); CustomerAndAccountList customerAndAccountList = new CustomerAndAccountList(); customerAndAccountList.setCustomer(customer); customerAndAccountList.setAccountList(accountList); return customerAndAccountList; } ... }   非接口约定调用：采用平台通用JSONObject类型，Interface接口类统一采用BizMessageInterface接口类，并统一用call()来调用应用层聚合服务。如下例所示：  @Service public class PersonalAppService implements PersonalAppInterface { ... private BizMessageInterface payment1SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment1-sink\u0026quot;); private BizMessageInterface payment2SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment2-sink\u0026quot;); ... @Override public BizMessage\u0026lt;JSONObject\u0026gt; send2Payment1(Object message) throws BizException { JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;message\u0026quot;,message); return this.payment1SinkInterface.call(jsonObject); } @Override public BizMessage send2Payment2(String tranMode, String tranCode, Object message) throws BizException { JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;tranCode\u0026quot;,tranCode); jsonObject.set(\u0026quot;tranMode\u0026quot;,tranMode); jsonObject.set(\u0026quot;message\u0026quot;,message); return this.payment2SinkInterface.call(jsonObject); } ... }  3. App调用延迟服务 延迟服务也是位于应用层的App服务，延迟服务只能由应用层的App服务来进行嵌套调用，不能从适配层直接调用延迟服务。 App调用延迟服务，统一采用“IntegratorClientFactory.getDelayBizServiceClient(Class tClass, String bizServiceId, int\u0026hellip; delayMilliseconds)”来调用（tClass必须是接口类），同样有接口约定调用和非接口约定调用二种方式，其中非接口约定调用是采用BizMessageInterface接口类，并统一用call()来调用应用层聚合服务，如下例所示：\n@Service public class PersonalAppService implements PersonalAppInterface { private AccountSinkInterface accountSinkInterface = IntegratorClientFactory .getSinkClient(AccountSinkInterface.class,\u0026quot;account-sink\u0026quot;); private CustomerSinkInterface customerSinkInterface = IntegratorClientFactory .getSinkClient(CustomerSinkInterface.class,\u0026quot;customer-sink\u0026quot;); private BizMessageInterface payment1SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment1-sink\u0026quot;); private BizMessageInterface payment2SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment2-sink\u0026quot;); private PersonalAppInterface personalAppDelayInterface = IntegratorClientFactory .getDelayBizServiceClient(PersonalAppInterface.class,\u0026quot;app/personal\u0026quot;, 0,1000,2000,4000,8000,16000,32000); ... @Override public void payoutForward(String tranMode,String accountId, long amount) throws BizException { log.info(\u0026quot;account出金:{},{}\u0026quot;,accountId,amount); this.accountSinkInterface.payout(accountId,amount); JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;tranCode\u0026quot;,\u0026quot;pay\u0026quot;); jsonObject.set(\u0026quot;tranMode\u0026quot;,tranMode); jsonObject.set(\u0026quot;accountId\u0026quot;,accountId); jsonObject.set(\u0026quot;tranAmount\u0026quot;,amount); BizMessage\u0026lt;JSONObject\u0026gt; bizMessage = null; try { log.info(\u0026quot;payment缴费...\u0026quot;); bizMessage = this.payment2SinkInterface.call(jsonObject); } catch (BizException e) { if (e.isTimeOutException()) { log.info(\u0026quot;payment交易超时,开始payout补偿...\u0026quot;); this.personalAppDelayInterface.payoutForwardCompensate(jsonObject); return; } else { throw e; } } log.info(\u0026quot;payment缴费成功!\u0026quot;); log.info(\u0026quot;payout成功!\u0026quot;); } }  三、开发Sink服务 通过Java来开发的Sink服务，主要支持以下二类：sink-bean类型、bean类型。\n1. sink-bean类sink服务 sink-bean主要有以下特点：\n sink接口为标准的BizMessage类型即可，其它没有格式约定； 在sink.yml中配置”sink-bean“类型的connector，服务类支持JavaBean和SpringBean二种挂接方式；  sink-bean的实现，应基于或接口开发服务类，实现process()方法，2个接口区别在于出入参数的类型。\n1.1 实现接口的sink服务 JSONObjectSinkBeanInterface接口中的process()出入参参数采用Biz-SIP标准的JSONObject：这种类型的sink服务一般不涉及到报文格式转换或报文格式转换由开发者自己编码完成，JSONObjectSinkBeanInterface接口约定如下：\npublic interface JSONObjectSinkBeanInterface { /** * JSONObject SinkBean服务调用接口 * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public JSONObject process(JSONObject packMessage) throws BizException; }  举例如下：\n@Service public class Payment2SinkService implements JSONObjectSinkBeanInterface { @Autowired private TimeoutCmdExe timeoutCmdExe; @Autowired private TimeoutAndFailCmdExe timeoutAndFailCmdExe; @Autowired private TimeoutAndSuccessCmdExe timeoutAndSuccessCmdExe; @Autowired private SuccessCmdExe successCmdExe; @Override public JSONObject process(JSONObject jsonObject) throws BizException { log.info(\u0026quot;传入消息:\\n{}\u0026quot;, jsonObject.toString()); AbstractSinkBeanCmdExe sinkBeanCmdExe; String tranMode = (String)jsonObject.get(\u0026quot;tranMode\u0026quot;); switch (tranMode) { case \u0026quot;timeout\u0026quot;: // 收到交易后，永远返回超时 return timeoutCmdExe.execute(jsonObject); case \u0026quot;3timeout-fail\u0026quot;: // 收到交易后，前3次返回超时，第4次返回失败码 return timeoutAndFailCmdExe.execute(jsonObject); case \u0026quot;3timeout-success\u0026quot;: // 收到交易后，前3次返回超时，第4次成功返回原报文 return timeoutAndSuccessCmdExe.execute(jsonObject); default: //其它情况,成功返回原报文 return successCmdExe.execute(jsonObject); } } }  1.2 实现接口的sink服务 SinkBeanInterface接口的process()出入参采用字节流byte[]：这种类型的sink服务一般是涉及到不同消息类型的转换，在sink.yml中支持多种convert，传入process()方法的参数为经过convert转换后的消息。SinkBeanInterface接口约定如下：\npublic interface SinkBeanInterface { /** * Java服务调用接口 * @param beforeJsonObject 打包前的JsonObject * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public byte[] process(JSONObject beforeJsonObject, byte[] packMessage) throws BizException; }  在process()方法中传入的beforeJsonObject参数，是传入sink但还没经过打包的JSONObject对象，packMessage参数已经根据sink的消息格式配置，完成了对于目标消息格式的转换。 举例如下：\n@Service public class Payment1SinkService implements SinkBeanInterface { @Override public byte[] process(JSONObject beforeJsonObject, byte[] inMessage) throws BizException { log.info(\u0026quot;传入消息:\\n{}\u0026quot;, BizUtils.buildHexLog(inMessage)); return inMessage; } }  1.3 实现切面接口 在实现SinkBeanInterface或JSONObjectSinkBeanInterface接口时，可以通过实现SinkBeanAspectInterface切面接口，能在convertor处理前、处理后以及处理异常时实现注入逻辑，接口约定如下：\npublic interface SinkBeanAspectInterface { /** * * @param jsonObject 一般为convertor处理前传入的JSONObject * @return 经过处理后的JSONObject */ public JSONObject beforeProcess(JSONObject jsonObject); /** * * @param beforeJsonObject 一般为convertor处理前传入的JSONObject * @param afterJsonObject 经过process()处理后返回的JSONObject * @return */ public JSONObject afterProcess(JSONObject beforeJsonObject,JSONObject afterJsonObject); /** * * @param jsonObject 传入process()的JSONObject * @param bizException 在process()中抛出的异常 */ public void handleProcessException(JSONObject jsonObject,BizException bizException); }  2. bean类sink服务 bean类sink服务有以下特点：\n sink接口为BizMessage类型，JSONObject有格式要求，消息体中应包括：className（可选）、methodName（可选）、params（必选），params为JSONArray类型； 可自由开发服务类； 在sink.yml中配置”bean“类型的connector，服务类支持JavaBean和SpringBean二种挂接方式； 在sink.yml中convert只支持simple-json类型（后期可能会取消对于bean类sink服务的convert配置）。 bean类在开发时，一定要先定义一个Interface类，这个Interface类会被调用方（App应用层）所引用。  bean类sink服务，如下例所示：\n@Service public class AccountSinkService implements AccountSinkInterface { @Autowired private PayoutCmdExe payoutCmdExe; @Autowired private PayoutCompensationCmdExe payoutCompensationCmdExe; @Autowired private GetAccountListByCustomerIdCmdExe getAccountListByCustomerIdCmdExe; @Override public List\u0026lt;Account\u0026gt; getAccountListByCustomerId(String customerId) { return this.getAccountListByCustomerIdCmdExe.getAccountListByCustomerId(customerId); } @Override public Account payout(String accountId, long amount) { return this.payoutCmdExe.payout(accountId,amount); } @Override public Account payoutCompensation(String accountId, long amount) { return this.payoutCompensationCmdExe.payoutCompensation(accountId,amount); } }  四、开发app服务 通过Java来开发的app服务，主要支持以下二类：integrator-bean-service类型、bean-service类型。\n1. integrator-bean-service类app服务 integrator-bean-service主要有以下特点：\n sink接口为标准的BizMessage类型即可，其它没有格式约定； 在service.yml中配置type为”integrator-bean-service“，服务类只支持SpringBean的挂接方式；  integrator-bean-service的实现，应基于接口开发服务类，实现doBizService()方法。 IntegratorBeanInterface接口约定如下：\npublic interface IntegratorBeanInterface { /** * 执行聚合服务 * @param message 传入的消息 * @return 返回的消息 */ public abstract BizMessage\u0026lt;JSONObject\u0026gt; doBizService(BizMessage\u0026lt;JSONObject\u0026gt; message) throws BizException; }  举例如下：\n@Service public class IntegratorService3 implements IntegratorBeanInterface { private SinkInterface1 sinkInterface1 = IntegratorClientFactory .getSinkClient(SinkInterface1.class,\u0026quot;sink12\u0026quot;); private BizMessageInterface sinkInterface2 = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;sink1\u0026quot;); @Override public BizMessage\u0026lt;JSONObject\u0026gt; doBizService(BizMessage\u0026lt;JSONObject\u0026gt; message) throws BizException { String result1 = this.sinkInterface1.doService1(\u0026quot;001\u0026quot;); this.sinkInterface1.doService2(\u0026quot;002\u0026quot;,3); AccountDTO[] accountDTOs = this.sinkInterface1.queryAccounts(AccountDTO.builder().account(\u0026quot;002\u0026quot;).build()); List\u0026lt;AccountDTO\u0026gt; accountDTOList = this.sinkInterface1.queryAccountList(AccountDTO.builder().account(\u0026quot;002\u0026quot;).build()); CustomerDTO customerDTO = this.sinkInterface1.queryCustomerDTO(\u0026quot;001\u0026quot;); JSONObject jsonObject1 = new JSONObject(); jsonObject1.set(\u0026quot;accountNo\u0026quot;,\u0026quot;003\u0026quot;); BizMessage\u0026lt;JSONObject\u0026gt; bizMessage = this.sinkInterface2.call(jsonObject1); JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;result1\u0026quot;,result1); jsonObject.set(\u0026quot;accountDTOs\u0026quot;,accountDTOs); jsonObject.set(\u0026quot;accountDTOList\u0026quot;,accountDTOList); jsonObject.set(\u0026quot;customerDTO\u0026quot;,customerDTO); jsonObject.set(\u0026quot;sink1\u0026quot;,bizMessage.getData()); return BizMessage.buildSuccessMessage(message,jsonObject); } }  2. bean-service类app服务 bean-service类app服务有以下特点：\n app接口虽然都要求为BizMessage类型，但是对JSONObject有格式要求，消息体中应包括：className（可选）、methodName（可选）、params（必选），params为JSONArray类型； 可自由开发服务类，但上送JSONObject的className、methodName、params应该和类接口相匹配； 在service.yml中配置”bean-service“类型的聚合服务，服务类只支持SpringBean来进行挂接； bean-service类在开发时，一定要先定义一个Interface类，这个Interface类会被调用方（一般是渠道层source，app服务如作为延迟服务会被应用层调用）所引用。  bean-service类app服务，如下例所示：\n@Service public class SinkClientInterface1Impl implements SinkInterface1 { private SinkInterface1 sinkInterface1 = IntegratorClientFactory.getSinkClient(SinkInterface1.class,\u0026quot;sink12\u0026quot;);; int retryNum = 0; @Override public String doService1(String arg1) { return this.sinkInterface1.doService1(arg1); } @Override public void doService2(String arg1, int arg2) { this.sinkInterface1.doService2(arg1,arg2); } @Override public CustomerDTO queryCustomerDTO(String customerId) { return this.sinkInterface1.queryCustomerDTO(customerId); } @Override public AccountDTO[] queryAccounts(AccountDTO accountDTO) { return this.sinkInterface1.queryAccounts(accountDTO); } @Override public List\u0026lt;AccountDTO\u0026gt; queryAccountList(AccountDTO accountDTO) { return this.queryAccountList(accountDTO); } ... } ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"4d83b0e0a022ed8a81f86ae18fa776c5","permalink":"http://bizsip.bizmda.com/doc/development/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/development/","section":"doc","summary":"介绍使用Java代码来开发基于Biz-SIP中间件的系统。\n","tags":null,"title":"系统开发","type":"book"},{"authors":null,"categories":null,"content":"介绍Biz-SIP中间件各模块间的接口类型和通讯方式。\n一、Biz-SIP内部标准消息规范 Biz-SIP中间件的内部消息规范如下：\n   参数 类型 是否必填 描述     code int Y 返回码，0为成功，非0为失败   message String N 返回消息   extMessage String N 返回扩展消息   traceId char(32) Y 由Biz-SIP统一生成的唯一跟踪ID，每个聚合服务中traceId相同   parentTraceId char(32) N 父交易服务的traceId，父交易服务一般调用SAF服务，会产生子交易服务   timestamp long Y 由Biz-SIP统一生成的时间戳，为聚合服务的最初发起时间，为1970年1月1日零点整至发起时间的毫秒数   data String（JSON格式） N 传送的数据，一般为JSON格式    二、渠道层Open API接口规范 Open API接口网关，是Biz-SIP中间件对外提供的标准接口接入，规范如下：\n   URL http://{地址}:{端口}/api     HTTP请求头    - Content-Type application/json   - Biz-Service-Id 调用的聚合服务ID   请求包 JSON报文   响应包 Biz-SIP内部标准消息（参见“Biz-SIP内部标准消息规范”）    三、应用层App Integrator接口规范 服务整合器（Integrator）接口，对外是以Spring Cloud微服务的形式提供的，内部调用是采用这种接口规范，同时接入非标接口的客户端适配器也是采用这个接口进行接入的，规范如下：\n   URL http://sip-integrator/api     HTTP请求头    - Content-Type application/json   - Biz-Service-Id 调用的聚合服务ID   请求包 JSON报文   响应包 Biz-SIP内部标准消息（参见“Biz-SIP内部标准消息规范”）    四、领域层Sink接口规范 Sink接口，是Integrator调用所有Sink模块的接口，规范如下：\n   Content-Type application/json     请求包 Biz-SIP内部标准消息（参见“Biz-SIP内部标准消息规范”）   响应包 Biz-SIP内部标准消息（参见“Biz-SIP内部标准消息规范”）   ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"c1cd9475676dac1c0a8eeb8d3a246e7d","permalink":"http://bizsip.bizmda.com/doc/interface/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/interface/","section":"doc","summary":"介绍Biz-SIP中间件各模块间的接口类型和通讯方式。\n","tags":null,"title":"接口规范","type":"book"},{"authors":null,"categories":null,"content":"介绍Biz-SIP中间件主要场景的运行机制。\n一、系统运行机制概述 1 系统架构 整个Biz-SIP中间件系统主要包括：应用层服务聚合模块（app integrator）、适配层服务接入模块（source）、领域层服务调用模块（sink）、Open API接口和内部基础服务五大块，其中：\n 应用层服务聚合模块（app integrator）：负责服务的整合和编排，对Source模块接入的聚合服务，进行服务编排，并通过Sink模块接入要编排的服务。目前支持Script脚本服务整合和Java SDK服务整合模式。 适配层服务接入模块（Source）：负责聚合服务的接入，包括通讯协议适配和消息格式转换，并统一接入Integrator。Source模块中的消息格式转换器（Source Converter）支持XML、JSON、定长、有分隔符、8583等报文的解包和打包。 领域层服务调用模块（Sink）：统一被Integrator所调用，负责接入要编排的服务，包括和外部服务对接时的通讯协议适配和消息格式转换。Sink模块中的Sink通讯连接器（Sink Connector）支持微服务、消息中间件、TCP长短连接等多种接入方式；Sink模块中的消息格式转换器（Sink Converter）支持XML、JSON、定长、有分隔符、8583等报文。 开放API接口（Open API）：对外提供的标准的API接口，提供所有聚合服务的接入，后面是接入服务聚合器（Integrator）。 内部基础服务：内置数据库、日志、事务管理等常用的服务，由Integrator编排到聚合服务中。  2 处理流程 Biz-SIP中间件的服务接入和处理流程，主要有标准接口接入和非标接口接入二种，其中标准接口接入是采用中间件约定的RESTful接口，不存在接入端的异构通讯适配和异构消息适配，比较简单，而非标接口接入会涉及异构通讯适配和异构消息适配的处理。 这里以比较复杂的非标接口接入为例，一个简单的调用方应用通过Biz-SIP中间件调用一个被调用方应用后就直接返回的场景，来描述一下整个处理流程： 第1步：是适配层Source模块，针对调用方不同异构通讯协议的适配接入，既可以采用现成的通讯接入模块配置接入，也可以代码自行实现。 第2步：Source模块在接入消息后，会调用Source API接口的process()方法。 第3步：process()方法会根据消息转换配置，进行消息解包。通过消息解包，会把调用方应用的消息转换成Biz-SIP中间件采用的JSON消息格式。 第4步：process()方法中，还会根据解包后的消息，通过聚合服务断言规则来定位要调用的聚合服务ID，聚合服务断言规则是对应config/source.yml文件中的service.service-rules配置项。\n 注：第2、3、4步，可以无需调用Source API接口的process()，由开发人员自行编码实现，\n 第5步：调用应用层App Integrator，开始调用约定的聚合服务，这个接口和标准接口接入的接口是同一个接口。 第6步：服务流程编排，是根据聚合服务配置来进行服务调用的编排，目前支持Script服务聚合器、基于Java开发的服务聚合器； 第7步：根据服务编排，会调用领域层Sink服务。 第9步：消息打包，既可以代码自行实现，也可以配置Sink Converter来实现。通过消息打包，会把Biz-SIP中间件采用标准JSON消息格式，转换成外部被调用方的消息格式。 第10步：调用Sink Connector，既可以采用现成的通讯接入模块配置接入，也可以代码自行实现。 第11步：Sink Connector和被调用方应用通讯调用和交互。 第13步：消息解包，同第9步，既可以编码实现，也可以配置Sink Converter来实现，通过消息解包，会把外部被调用方返回的消息，转成Biz-SIP中间件的标准JSON消息格式。 第16步：Integrator继续执行后续的服务编排脚本。 第18步：消息打包，具体类似第3步消息解包的工作，会把Biz-SIP中间件响应回来的JSON消息格式转换成调用方应用的响应消息。 第20步：通过Source模块，将响应消息返回给调用方应用。\n3 运行机制图 上图中：\n 蓝色虚框所呈现的部分，主要是Biz-SIP中间件的配置文件。 蓝底黑字所呈现的部分，表示是需要Java代码开发的，涉及适配层、应用层和领域层。 蓝色虚箭头线所涉及的接口，就是不同层次之间需要互相依赖的接口定义。  二、应用层App Integrator 1 功能介绍 App Integrator服务整合器主要是对聚合服务进行内部服务和外部服务的编排处理，系统架构上支持多种模式的服务整合器，目前支持服务聚合编排模式包括：\n 基于Script脚本的服务编排：通过编写类JavaScript的脚本文件，来实现领域层服务的聚合和编排； 基于Java代码开发的服务编排：开发人员通过Java代码的编写，实现领域层服务的编排，支持2种类型的Java服务类：  integrator-bean-service接口服务类：integrator-bean-service通过实现统一的接口来实现服务编排。 bean-service接口服务类：bean-service提供更为灵活的接口定义来实现服务编排。   领域层服务的直接透传：通过配置sink-service，可以快速把领域层sink服务透传发布到前端的适配层source和OpenAPI接口。  2 调用接口 App Integrator对外提供标准API接口接入，接口规范如下：\n   URL http://{地址}:{端口}/api     HTTP请求头    - Content-Type application/json   - Biz-Service-Id 调用的聚合服务ID   提交方式 POST   请求包 JSON报文   响应包 Biz-SIP内部标准消息（参见“Biz-SIP内部标准消息规范”）    三、Source服务接入模块 1 功能介绍 适配层Source模块主要是对接外部和系统内部其它系统的服务接入。 主要功能主要有：\n 通讯协议的对接：服务接入模块（Source）负责外部调用方服务的通讯接入； 消息转换：把外部多种消息格式，转换成平台内部通过的JSONObject消息类型； 调用应用层的App Integrator进行服务编排。  并根据Source端定义的消息类型，调用消息类型所对应的消息转换器（Source Converter），转换器负责进行消息的格式转换，支持XML、JSON、定长、有分隔符、8583等报文的解包和打包。\n2 运行流程 Source模块的运行流程如下：\n 通过模块配置或二次开发的通讯接口（可以调用配置好的connector，也可以代码自行实现），接入外部应用发来的消息报文； 对收到的消息进行解包，解包可以通过调用配置好的conveter，也可以在代码中自行编码实现，其中息格式转换配置是定义在source.yml中，并结合“config/converter”目录下的消息格式配置文件，实现对消息解包的配置化。 把解包好的消息，打包成JSON消息格式，发给Integrator； Integrator处理完成后，会用内部标准消息（BizMessage）格式返回； 对收到的消息进行打包，打包可以通过调用配置好的conveter，也可以在代码中自行编码实现。 通过第1步使用的通讯接口，把最终消息报文返回给外部应用。  四、Sink服务调用模块 1 功能介绍 Sink服务主要有二类：\n 一类是对接第三方应用； 另一类是领域层的交易处理模块。  Sink服务的功能主要是二个：\n 通讯协议的对接：Sink Connect负责和调用系统的通讯对接，支持微服务、消息中间件、TCP长短连接等多种接入方式； 消息格式的转换：Sink Converter负责调用服务消息的格式转换，支持XML、JSON、定长、有分隔符、8583等报文。  2 运行流程 Sink模块的运行流程如下：\n 收到Integrator发来的消息报文（参照服务端适配器接口规范）； 对收到的消息进行打包，打包可以通过调用配置好的conveter，也可以在代码中自行编码实现，其中息格式转换配置是定义在source.yml中，并结合“config/converter”目录下的消息格式配置文件，实现对消息打包的配置化。 根据Sink端约定的通讯协议类型，可以选择基于配置的Sink Connector，也可以代码自行开发通讯接口，和外部应用进行消息报文交互； 对外部应用返回的消息，进行解包，解包可以通过调用配置好的conveter，也可以在代码中自行编码实现； 把解包成功的JSONObject平台消息报文，返回给Integrator。  3 Sink服务类型 Sink目前支持4种Sink服务类型：netty、rabbitmq、sink-bean、bean。 其中netty和rabbitmq是开箱即用的Sink服务，通过配置接入参数，就能快速实现TCP短连接和RabbitMQ RPC连接。 sink-bean和bean服务类型，是提供Java开发框架，由Java开发人员来自行开发的，其中：\n sink-bean是基于报文消息的对接，一般用来对接采用报文通讯的第三方。 bean是基于接口类的实现，接口比较严格，一般用来对接内部实现的交易处理系统。  五、延迟服务 延迟服务主要用于Saga分布式事务和SAF存储转发的处理，主要场景有：\n 重试通知：通知对方系统，直到对方给出明确的回复响应。 向前补偿：调用第三方服务后，超时没有响应，系统会后续发起查询上笔交易状态的查询交易，根据查询交易状态来决定继续完成后续服务步骤还是对以前服务步骤发起补偿（冲正）操作。 向后补偿：调用第三方服务后，超时没有响应，系统会立即发起针对此交易的补偿交易，补偿成功后，会对以前服务步骤依次发起补偿（冲正）操作；如果补偿失败，会置交易失败，由人工介入处理。  以上这几种事务场景，都是调用延迟服务的方式来实现的，调用方式主要有二种：\n Script脚本中调用：在脚本中通过“sip.doDelayService()”调用来实现。 Java调用：通过“IntegratorClientFactor.getDelayBizServiceClient()”获得延迟服务调用句柄，来进行延迟服务的调用。  以Java调用为例，针对延迟服务的执行流程，如下图所示：  适配层调用App Integrator后，会执行指定的聚合服务； 在Java编写的聚合服务中，会首先约定一个聚合服务调用的接口xxxDelayInterface，会声明接口类型、调用延迟间隔时间和调用次数； 在Java编写的服务中，可以通过前面声明的xxxDelayInterface接口，发起延迟服务的调用； 发起延迟消息后，在平台内部实现机制上，是通过发送RabbitMQ延迟消息的方式来实现的； 事务管理器在延迟服务接口约定的延迟时间后，会收到RabbitMQ消息，调起聚合服务（子服务）的处理； 如果执行成功，则延迟服务顺利完成，父服务和子服务都标记为成功； 如果在执行中抛出BizTimeOutException异常，则会结束当前延迟服务，等待延迟服务的再次唤起； 如果在执行中抛出其它BizException异常，则会结束当前延迟服务，标记父服务和子服务为失败，等待人工后续处理； 延迟服务唤起次数超限，也会会结束当前延迟服务，标记父服务和子服务为失败，等待人工后续处理。 ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"e952da95971db1f5baf3061435a98609","permalink":"http://bizsip.bizmda.com/doc/know-how/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/know-how/","section":"doc","summary":"介绍Biz-SIP中间件主要场景的运行机制。\n","tags":null,"title":"运行原理","type":"book"},{"authors":null,"categories":null,"content":"介绍对Biz-SIP中间件模块进行增加类型和扩展功能的进阶开发。\n一、应用层App Integrator 1 Script服务整合器脚本函数的扩展 Script服务整合器是构建在magic-script脚本解析器基础上的服务编排引擎，通过解释执行service目录下的*.script文件，实现内外部服务整合和编排运行。 service目录下所有的“*.script”文件，都是Script服务整合器脚本。脚本语言采用magic-script（https://gitee.com/ssssssss-team/magic-script），这是一款基于JVM的脚本语言。 在Script服务整合器脚本中，主要使用的特殊对象包括：sip对象、log对象等。 其中sip对象是对应于com.bizmda.bizsip.integrator.executor.script.SipFunctions类，可以扩展这个类来实现sip对象函数的开发。\n2 应用层App Integrator扩展开发 Biz-SIP提供开箱即用的Script聚合服务整合器，不过开发人员可以对聚合服务整合器进行二次开发和扩展，扩展新的聚合服务整合器。 目前Biz-SIP中间件支持的聚合服务，是从config/service目录下文件进行装载的，聚合服务ID（serviceId）是由“目录名+文件名前缀”来表示的，聚合服务类型（type）是由文件名后缀来表示的，具体的聚合服务类型和实现类的关系，在AbstractIntegratorService类中进行关联：\npublic final static Map\u0026lt;String,Class\u0026gt; SERVICE_SCRIPT_SUFFIX_MAP = new HashMap\u0026lt;String,Class\u0026gt;(){{ put(\u0026quot;script\u0026quot;, ScriptIntegratorService.class); }};  具体的聚合服务整合器实现类，都是AbstractIntegratorService抽象类的子类，在Biz-SIP中间件加载时，会对每一个在config/service目录下的聚合服务文件，都会根据文件后缀来实例化对应的聚合服务整合器实现类，AbstractIntegratorService抽象类主要有2个主要的方法：\n init()：用于聚合服务整合器实现类的初始化； doBizService()：在Biz-SIP通过开放API接口收到聚合服务请求时，具体的聚合服务处理过程，在这个doBizService()方法中实现，Script聚合服务整合器类（ScriptIntegratorService.java）是采用magic-script来驱动的，也可以采用其它方式来实现聚合服务的整合处理。  聚合服务整合器（Integrator）的处理活动图如下： 要实现一个新的聚合服务器实现类，主要开发流程如下：\n 继承AbstractIntegratorService，实现init()、doBizService()共2个方法； 将实现的聚合服务器实现类，在AbstractIntegratorService类的SERVICE_SCRIPT_SUFFIX_MAP中添加，key为新的聚合服务配置文件约定的文件后缀名，注意不要和原有的类型冲突，value为具体的聚合服务器实现类。  二、Source服务接入模块 Biz-SIP会提供开箱即用的Source模块，不过对于较为特殊的外部应用服务接入，还是需要开发定制的。 在开发服务接入模块时，需要在项目pom.xml中引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.bizmda.bizsip\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;source-spring-cloud-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  Source模块的处理核心是Source类，Source类主要有2个主要的方法：\n init()：用于客户端适配器的初始化，主要是一些相关配置信息加载的工作； process()：具体在收到外部应用消息后和返回外部应用之间，所要做的处理工作，主要是解包、调用聚合服务、打包等工作。  Source模块的处理活动图如下： 从上面的活动图可以看到，二次开发工作主要集中在服务接入模块初始化、通讯接入和读取消息这些部分。\n三、Sink服务调用模块 Biz-SIP提供了开箱即用的服务调用模块，二次开发主要在消息处理器和协议处理器的，对于服务接入模块本身，只是简单地加载和调用Sink类即可，无需过多的二次开发操作。 在做服务调用模块的开发时，需要在项目pom.xml中引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.bizmda.bizsip\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sink-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  服务调用模块的处理核心是Sink类，Sink类主要有2个主要的方法：\n init()：用于Sink端的初始化，主要是一些相关配置信息加载的工作； process()：具体在被服务整合器（Integrator）调用后，所要做的处理工作，主要是消息打包、调用外部应用服务、消息解包等工作。  服务调用模块的处理活动图如下： 从上面的活动图可以看到，服务调用模块的二次开发工作很少，主要是对于Sink类的初始化和调用，对通讯的个性化开发，是放在连接器（Connector）中开发的。\n四、Converter转换器（消息适配） 所有消息处理器的实现类，有一个公共的抽象父类——AbstractConverter类，解包和打包，分别这调用AbstractConverter类的pack()和unpack()方法。 解包（AbstractConverter类的unpack()方法）流程如下：\n 将外部报文进行预解包，这是调用AbstractConverter类的adaptor2json()方法，该方法是根据消息类型配置和相关参数，对外部消息预解成中间的JSON格式的消息，以进行后续进一步处理； 对预解包进行最终的解包，这是调用AbstractConverter类的json2biz()方法，该方法是用上一步的预解包消息，组织Biz-SIP内部标准JSON消息；在解包时，可能会涉及到格式转换文件的断言规则判断（调用AbstractConverter类的matchMessagePredicateRule()方法），这是根据消息类型来定的。打包（AbstractConverter类的pack()方法）流程如下： 根据内部标准JSON消息进行预打包，这是调用AbstractConverter类的biz2json()方法；在预打包时，可能会涉及到格式转换文件的断言规则判断（调用AbstractConverter类的matchMessagePredicateRule()方法），这是根据消息类型来定的。 实现最终的打包，这是调用AbstractConverter类的json2adaptor()方法，这是根据适配器所设置的参数来定的。  目前Biz-SIP中间件支持simple-json、simple-xml、velocity-json等消息格式，具体的实现类在AbstractConverter类中进行关联：\npublic static final Map\u0026lt;String,Object\u0026gt; CONVERTER_TYPE_MAP = new HashMap\u0026lt;\u0026gt;(); static { CONVERTER_TYPE_MAP.put(\u0026quot;simple-json\u0026quot;, SimpleJsonConverter.class); CONVERTER_TYPE_MAP.put(\u0026quot;simple-xml\u0026quot;, SimpleXmlConverter.class); CONVERTER_TYPE_MAP.put(\u0026quot;velocity-json\u0026quot;, VelocityJsonConverter.class); CONVERTER_TYPE_MAP.put(\u0026quot;velocity-xml\u0026quot;, VelocityXmlConverter.class); CONVERTER_TYPE_MAP.put(\u0026quot;fixed-length\u0026quot;, FixedLengthConverter.class); CONVERTER_TYPE_MAP.put(\u0026quot;velocity-split\u0026quot;, VelocitySplitConverter.class); }  要实现新的消息处理器，主要开发流程如下：\n 继承AbstractConverter，实现biz2json()、json2adaptor()、adaptor2json()、json2biz()这4个方法； 将实现的消息处理类，在AbstractConverter类的CONVERTER_TYPE_MAP中添加。  五、域处理函数 域处理函数用在消息格式转换处理中，包括预解包、解包和打包，一般会对域中的值进行一定的处理。 目前支持的域处理函数如下：\n   域处理函数名 说明 参数     fill 填充 参数1（必选）：填充方式，left/right分别代表左填充和右填充   参数2（必选）：填充字符     参数3（可选）：填充长度，缺省为当前域长度     trim 去除空格 参数1（可选）：left/right分别代表去左边空格和去右边空格，缺省为左右空格都去掉。   decimalFormat 对数字进行格式化 参数1（必选）：根据Java中的DecimalFormat类格式，对数字进行格式化    所有的域处理函数，都在com.bizmda.bizsip.message.fieldfunction.FieldFunctionImpl类中实现，每个域处理函数都是FieldFunctionImpl类中的一个静态方法，函数名即静态方法名。 静态方法的原型为：\npublic static String xxxxxx(Object fieldValue, int fieldLen, List\u0026lt;String\u0026gt; args) { ...... }  其中，xxxxxx即为要实现的域处理函数的函数名，输入参数包括：\n fieldValue：要处理域的域值。 fieldLen：要处理域的域定义长度，一般是在格式转换配置文件中约定的。 args：多个输入参数，每个域处理函数自行约定，是在格式转换配置文件中会定义域处理函数的输入参数。  六、Connector连接器（通讯适配） 连接器（Connector）是支持通讯协议接入的，协议处理器主要是为Sink模块服务的，被Sink模块类所调用，Source模块不支持协议处理器。 所有协议处理器的实现类，有一个公共的抽象父类——AbstractSinkConnector类，主要涉及方法有：\n init()：进行协议处理器的初始化装载，参数会传入服务适配器的配置参数； process()：具体和外部应用交互的处理过程，传入参数和返回参数都为Object类。  Biz-SIP中间件只支持java、Netty、RabbitMQ等通讯连接类型，具体的实现类在AbstractSinkConnector类中进行关联：\npublic static final Map\u0026lt;String,Object\u0026gt; CONNECTOR_TYPE_MAP = new HashMap\u0026lt;\u0026gt;(); static { CONNECTOR_TYPE_MAP.put(\u0026quot;java\u0026quot;, JavaSinkConnector.class); CONNECTOR_TYPE_MAP.put(\u0026quot;springbean\u0026quot;, SpringBeanSinkConnector.class); CONNECTOR_TYPE_MAP.put(\u0026quot;netty\u0026quot;, NettySinkConnector.class); CONNECTOR_TYPE_MAP.put(\u0026quot;rabbitmq\u0026quot;, RabbitmqSinkConnector.class); CONNECTOR_TYPE_MAP.put(\u0026quot;javaapi\u0026quot;, JavaApiSinkConnector.class); }  要实现新的协议处理器，主要开发流程如下：\n 继承AbstractServerProtocolProcessor类，实现init()、process()这2个方法； 将实现的消息处理类，在AbstractServerProtocolProcessor类的PROTOCOL_TYPE_MAP中添加。 ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"65730bf0f1b9dc6e703f19456334bd0f","permalink":"http://bizsip.bizmda.com/doc/extend/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/extend/","section":"doc","summary":"介绍对Biz-SIP中间件模块进行增加类型和扩展功能的进阶开发。\n","tags":null,"title":"扩展开发","type":"book"},{"authors":null,"categories":null,"content":"通过xbank项目来介绍用Biz-SIP中间件开发一个系统的全流程\nxbank项目版本库：https://gitee.com/szhengye/xbank.git\n一、Biz-SIP架构和DDD领域驱动设计入门介绍 1. DDD领域驱动设计 2004年，Eric Evans完成了《Domain-Driven Design Tackling Complexity in the Heart of Software》一书，提出了一套针对业务领域建模的方法论和思想\u0026ndash;领域驱动设计，简称DDD。 领域驱动设计（DDD）是一种基于模型驱动的软件设计方式。它以领域为核心，分析领域中的问题，通过建立一个领域模型来有效地解决领域中的核心、复杂问题。 领域驱动设计提出了一套核心构造块（Building Blocks），如聚合、实体、值对象、领域服务、领域工厂、仓储、领域事件等。这些构造块是对面向对象领域建模的一些核心最佳实践的浓缩。这些构造块可以使得我们的设计更加标准、有序。 利用 DDD 提倡的分层、六边形等架构，分离了业务复杂度和技术复杂度，使得系统具备更强的扩展性和弹性；战术层面提供了元模型（聚合，实体，值对象，服务，工厂，仓储等等）帮助构建清晰、稳定，能快速响应变化和新需求能力的应用。\n2. COLA架构 COLA 4.0 推荐的应用架构如下图所示： 1）适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，对于传统B/S系统而言，adapter就相当于MVC中的controller； 2）应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层； 3）领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次； 4）基础设施层（Infrastructure Layer)：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。\n 二、体验Biz-SIP示例项目xbank 1. 示例项目xbank简介 xbank是一家商业银行，面向个人客户和公司客户，其中个人客户业务包括存款、贷款、缴费等业务；银行业务渠道除了传统柜面以外，还有网上银行、手机银行、ATM、POS等，最近准备上一个针对银行合作伙伴的基于OPENAPI网关的开放平台渠道。 本示例项目是以个人客户中的存款查询和缴费业务为例子，渠道采用OPENAPI开放接口，后台系统对接个人客户存款系统和个人客户信息系统，第三方对接缴费平台，来演示如何打造基于Biz-SIP中间件的银行业务中台。 按DDD分层架构，应用架构图如下所示： 3. xbank示例项目模板介绍 打开示例项目，如下图： xbank项目分为以下模块：\n xbank-source：适配层模块，存放外部适配接入的适配层实现。  xbank-openapi-source：OPENAPI接入的适配层子模块   xbank-app：应用层模块，存放应用层的服务实现。 xbank-sink：领域层模块，存放按领域划分的领域服务实现。  xbank-account-sink：账户域子模块 xbank-customer-sink：客户域子模块 xbank-payment1-sink：缴费域子模块（存储转发） xbank-payment1-sink：缴费域子模块（交易补偿）   xbank-infrastructure：基础设施层模块，存放对数据库、内容存储、HSM等基础设施的访问能力实现。  xbank-account-db：账户数据库访问子模块 xbank-customre-db：客户数据库访问子模块   xbank-client：接口模块，存放各层之间的服务接口，以及相关数据DTO。  xbank-account-sink-client：账户域服务接口子模块 xbank-customer-sink-client：客户域服务接口子模块 xbank-app-client：应用服务接口子模块    4. 创建数据库 执行项目中xbank-infrastructure/xbank-sql/xbank.sql脚本，以建立xbank演示库。\n5. 启动xbank项目  启动应用层服务整合器  执行xbank-app模块中的XbankAppApplication   启动领域层领域服务  执行xbank-customer-sink子模块中的CustomerSinkApplication 执行xbank-account-sink子模块中的AccountSinkAppliction   启动适配层OPENAPI接入服务  执行xbank-openapi-source子模块中的OpenapiSourceApplication    4. 测试接口 4.1 查询客户信息 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:sink/customer\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomer\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;2d3ed69623f8480a9d95bcd3ca03a4d3\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630677591308, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } }  4.2 查询账户列表 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:sink/account\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getAccountListByCustomerId\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;748b76566a5e436e9c2990cf9776789f\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630677747532, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: [ { \u0026quot;accountId\u0026quot;: \u0026quot;0001\u0026quot;, \u0026quot;balance\u0026quot;: 100, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; }, { \u0026quot;accountId\u0026quot;: \u0026quot;0002\u0026quot;, \u0026quot;balance\u0026quot;: 200, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; } ] } }  4.3 查询客户信息和账户列表 $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomerAndAccountList\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;4fa2f86c23ce4b24abb1b0d23833c14f\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630677780246, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;accountList\u0026quot;: [ { \u0026quot;accountId\u0026quot;: \u0026quot;0001\u0026quot;, \u0026quot;balance\u0026quot;: 100, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; }, { \u0026quot;accountId\u0026quot;: \u0026quot;0002\u0026quot;, \u0026quot;balance\u0026quot;: 200, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; } ], \u0026quot;customer\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } } }   三、项目实践：客户域服务的开发 1. 创建数据库 执行项目中xbank-infrastructure/xbank-sql/xbank.sql脚本，以建立xbank演示库。\n2. 自动生成数据访问层代码 数据库创建后，用MybatisX插件自动生成数据访问层代码： 3. Customer领域服务接口和实现类的开发 先在xbank-customer-domain-client子模块中约定customer领域服务接口，这个接口是共享给领域层和应用层的： 然后在xbank-customer-sink子模块中完成以下工作：\n 基于此接口完成CustomerSinkService类的编写； 完成CustomerSinkApplication启动类的编写； 配置application.yml相关文件。  以上就完成了客户领域服务微服务的开发，接下来需要把这个客户领域服务微服务，通过sink接入Biz-SIP平台，配置xbank-app/config/sink.yml，就把CustomerSinkService类挂接到了sink（customer-sink)上： 4. Customer领域服务的快速发布 Customer领域服务接入Biz-SIP平台后，能实现在Biz-SIP开放平台接口的快速发布，这需要在xbank-app/config/service.yml中配置一个类型为“sink-service”的聚合服务： 注：这类“sink-service”的聚合服务，命名规范为“sink/xxx”，xxx为sink名称。 启动Biz-SIP平台和Customer领域服务，就可以直接在Biz-SIP开放平台接口进行访问：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:sink/customer\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomer\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;e763a42f9a2a49518c2bc6c157d08bab\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630740781540, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } }  在上传的数据体中，“methodName”为方法名，“params”为输入参数。\n5. Customer领域服务在应用层和适配层的定制 通过在service.yml中配置sink-service聚合服务，能实现已经挂接到Sink的领域服务的快速发布；但是，客户针对应用层和适配层，还是有个性化定制要求，这就涉及到应用层和适配层的定制。 同样以已经挂接到customer-sink上的Customer领域服务为例，先在xbank-app-client子模块中约定应用层接口，这个接口是共享给应用层和适配层的： 然后在xbank-app模块中基于此接口完成PersonalAppService类的编写： 在xbank-app/config/service.yml中配置一个类型为“bean-service”的聚合服务，并类名指定为上面实现的PersonalAppService应用层服务类： 最后在适配层中，定制一个controller来对外发布服务： 开发者可以在适配层的controller类中通过personalAppInterface，直接调用应用层的PersonalAppService服务：\n$ curl http://localhost:9001/personal/getCustomer\\?customerId=001|jq { \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;age\u0026quot;: 30, \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot; }  四、项目实践：账户域服务的开发 1. Account领域服务的封装 Account领域服务是和Customer领域服务并列的，Account领域服务的封装，依次有以下步骤：\n 第1步：领域服务接口的约定：在xbank-account-sink-client中编写AccountSinkInterface接口； 第2步：领域服务的实现：创建xbank-account-sink子模块，基于第1步约定的接口，实现AccountSinkService SpringBean，并封装成能独立运行的微服务应用； 第3步：配置sink.yml文件，把AccountSinkService SpringBean作为Sink连接到Biz-SIP平台；  另外，Account领域服务在封装时，涉及到多个接口调用，对每个接口采用命令执行器（Command Executor），所有的接口实现继承AbstractBeanCmdExe类来实现： 2. Account服务在适配层和应用层的开发和对外暴露 把sink服务，暴露给适配层接口调用，有2种方案：\n 方案一：\n 通过sink-service类型，打通适配层和应用层：直接把account领域服务所对应的sink，直接暴露给Biz-SIP开放平台接口。\n 第4步：配置service.yml文件，把account-sink直接作为sink-service暴露给Biz-SIP开放平台接口。  接口测试如下：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:sink/account\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getAccountListByCustomerId\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;2280472dd72c4ee4a2b7214604e9cf27\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630751382623, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: [ { \u0026quot;accountId\u0026quot;: \u0026quot;0001\u0026quot;, \u0026quot;balance\u0026quot;: 100, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; }, { \u0026quot;accountId\u0026quot;: \u0026quot;0002\u0026quot;, \u0026quot;balance\u0026quot;: 200, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; } ] } }   方案二：\n 通过bean-service，打通适配层和应用层：\n 第4步：应用服务接口的约定：在xbank-personal-app-client中编写PersonalAppInterface接口和CustomerAndAccountList DTO类； 第5步：应用服务的实现：在xbank-app模块中，基于第4步约定的接口实现PersonalAppService服务； 第6步：配置service.yml文件，把第5步开发PersonalAppService服务，通过bean-service的account-sink暴露给适配层； 第7步：在适配层创建xbank-openapi-source子模块，开发PersonalController类，暴露个性化的REST接口，并通过SourceClientFactory.getBizServiceClient(PersonalAppInterface.class,\u0026ldquo;app/personal\u0026rdquo;)获取应用层服务的调用接口（具体请参见链接），在适配层中调用应用层约定接口。  接口测试如下：\n$ curl http://localhost:9001/personal/getAccountListByCustomerId\\?customerId=001|jq [ { \u0026quot;accountId\u0026quot;: \u0026quot;0001\u0026quot;, \u0026quot;balance\u0026quot;: 100, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; }, { \u0026quot;accountId\u0026quot;: \u0026quot;0002\u0026quot;, \u0026quot;balance\u0026quot;: 200, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; } ]  五、项目实践：客户域和账户域服务在应用层的编排 上面已经分别实现了客户域和账户域服务的开发和部署，在应用层中，能方便地对域服务进行服务编排。 在xbank-app模块中，我们可以在PersonalAppService类中，方便地进行服务编排，代码如下：\n@Service public class PersonalAppService implements PersonalAppInterface { private AccountSinkInterface accountSinkInterface = IntegratorClientFactory .getSinkClient(AccountSinkInterface.class,\u0026quot;account-sink\u0026quot;); private CustomerSinkInterface customerSinkInterface = IntegratorClientFactory .getSinkClient(CustomerSinkInterface.class,\u0026quot;customer-sink\u0026quot;); private BizMessageInterface payment1SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment1-sink\u0026quot;); private BizMessageInterface payment2SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment2-sink\u0026quot;); private PersonalAppInterface personalAppDelayInterface = IntegratorClientFactory .getDelayBizServiceClient(PersonalAppInterface.class,\u0026quot;app/personal\u0026quot;, 0,1000,2000,4000,8000,16000,32000); @Override public CustomerAndAccountList getCustomerAndAccountList(String customerId) { Customer customer = this.customerSinkInterface.getCustomer(customerId); List\u0026lt;Account\u0026gt; accountList = this.accountSinkInterface.getAccountListByCustomerId(customerId); CustomerAndAccountList customerAndAccountList = new CustomerAndAccountList(); customerAndAccountList.setCustomer(customer); customerAndAccountList.setAccountList(accountList); return customerAndAccountList; } ... }  在getCustomerAndAccountList()方法中，我们可以同时调用客户域的接口customerSinkInterface，也可以调用账户域的接口accountSinkInterface，从而实现多个域服务的混合编排。 这个聚合服务通过bean-service进行部署： ，分别支持Biz-SIP开放平台接口访问和个性化的PersonController实现的REST接口：\n 通过Biz-SIP开放平台接口测试：  $ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomerAndAccountList\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;c3cda0e1b95f449e986dc5ee41e48716\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1630760469452, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;accountList\u0026quot;: [ { \u0026quot;accountId\u0026quot;: \u0026quot;0001\u0026quot;, \u0026quot;balance\u0026quot;: 100, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; }, { \u0026quot;accountId\u0026quot;: \u0026quot;0002\u0026quot;, \u0026quot;balance\u0026quot;: 200, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot; } ], \u0026quot;customer\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } } }   通过个性化PersonController实现的REST接口，接口测试如下：  $ curl http://localhost:9001/personal/getCustomerAndAccountList\\?customerId=001|jq { \u0026quot;customer\u0026quot;: { \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;age\u0026quot;: 30, \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot; }, \u0026quot;accountList\u0026quot;: [ { \u0026quot;accountId\u0026quot;: \u0026quot;0001\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;balance\u0026quot;: 100 }, { \u0026quot;accountId\u0026quot;: \u0026quot;0002\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;balance\u0026quot;: 200 } ] }  六、项目实践：支付域服务的开发 1. Payment领域服务的封装 payment领域服务是对接第三方缴费平台的，第三方缴费平台的接口是XML报文格式。 payment领域服务是属于对接第三方的领域服务，前面提到的customer领域服务和account领域服务，主要是内部交易处理的领域服务。 这二类领域服务在开发时有比较大的不同：\n 对接第三方的领域服务，一般涉及到复杂的通讯接口对接和报文格式转换； 内部交易处理领域服务，应用层和领域层之间，建议采用约定的Interface接口类的调用约定（底层Biz-SIP平台自动转换成RESTful协议和BizMessage标准消息进行交互）。  在开发对接第三方的领域服务时，建议采用实现SinkBeanInterface接口的JavaBean或SpringBean：\npublic interface SinkBeanInterface { /** * Java服务调用接口 * @param beforeJsonObject 打包前的JsonObject * @param packMessage 传入的消息 * @return 返回值 * @throws BizException */ public byte[] process(JSONObject beforeJsonObject, byte[] packMessage) throws BizException; }  在process()方法中传入的beforeJsonObject参数，是传入sink但还没经过打包的JSONObject对象，packMessage参数已经根据sink的消息格式配置，完成了对于目标消息格式的转换。 ​\nPayment领域服务的封装，依次有以下步骤：\n 第1步\n 领域服务的实现：创建xbank-payment1-sink子模块，根据SinkBeanInterface接口，实现Payment1SinkService微服务，并封装成能独立运行的微服务应用：\n@Service public class Payment1SinkService implements SinkBeanInterface { @Override public byte[] process(JSONObject beforeJsonObject, byte[] inMessage) throws BizException { log.info(\u0026quot;传入消息:\\n{}\u0026quot;, BizUtils.buildHexLog(inMessage)); return inMessage; } }   第2步\n 在sink.yml文件中，把Payment1SinkService微服务作为Sink连接到Biz-SIP平台：\n- id: payment1-sink type: rest url: http://payment1-sink/sink converter: type: simple-xml connector: type: sink-bean class-name: com.xbank.sink.payment.service.Payment1SinkService spring-bean: true  2. Payment服务的快速发布 配置service.yml文件，把payment-sink直接作为sink-service暴露给Biz-SIP开放平台接口：\n- bizServiceId: sink/payment1 type: sink-service sinkId: payment1-sink  接口测试如下：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:sink/payment1\u0026quot; -X POST --data '{\u0026quot;message\u0026quot;:\u0026quot;Hello world!\u0026quot;}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;af37bbbb495744d79f2f1811178436f5\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631153112943, \u0026quot;data\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;Hello world!\u0026quot; } }  Payment1SinkApplication会打印出日志，收到了完成消息转换后的XML报文：\n2021-09-09 10:05:13.265 INFO 10756 --- [nio-8003-exec-1] c.x.d.p.service.Payment1DomainService : 传入消息: ====+ 01-02-03-04-05-06-07-08-09-10-11-12-13-14-15-16-17-18-19-20 + ====== ASCII ====== + 0000: 3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E 3D 22 31 2E 30 22 20 | \u0026lt;?xml version=\u0026quot;1.0\u0026quot; | 0020: 65 6E 63 6F 64 69 6E 67 3D 22 55 54 46 2D 38 22 20 73 74 61 | encoding=\u0026quot;UTF-8\u0026quot; sta | 0040: 6E 64 61 6C 6F 6E 65 3D 22 6E 6F 22 3F 3E 3C 72 6F 6F 74 3E | ndalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt; | 0060: 3C 6D 65 73 73 61 67 65 3E 48 65 6C 6C 6F 20 77 6F 72 6C 64 | \u0026lt;message\u0026gt;Hello world | 0080: 21 3C 2F 6D 65 73 73 61 67 65 3E 3C 2F 72 6F 6F 74 3E | !\u0026lt;/message\u0026gt;\u0026lt;/root\u0026gt;.. |  3. payment领域服务在应用层和适配层的定制 通过在service.yml中配置sink-service聚合服务，能实现已经挂接到Sink的领域服务的快速发布。 但是，客户针对应用层和适配层，还是有个性化定制要求，这就涉及到应用层和适配层的定制。 例如我们要实现一个把消息发送给缴费平台的业务，输入的消息包括：交易码、传递的消息。 首先，需要在xbank-personal-app-client子模块中的PersonalAppInterface接口，增加一个消息发送接口send2payment1()，这个接口是共享给应用层和适配层的：\npublic interface PersonalAppInterface { ... public BizMessage send2Payment1(Object message) throws BizException; ... }  然后在xbank-app模块中基于此接口方法。在PersonalAppService类实现接口：\npublic class PersonalAppService implements PersonalAppInterface { ... private BizMessageInterface payment1DomainInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment1-sink\u0026quot;); ... @Override public BizMessage\u0026lt;JSONObject\u0026gt; send2Payment1(Object message) throws BizException { JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;message\u0026quot;,message); return this.payment1DomainInterface.call(jsonObject); } ... }  由于payment领域服务没有另外约定接口，是采用BizMessage标准消息接口，所以是采用BizMessageInterface接口来构建sink调用接口的，并统一通过call()方法来调用领域服务。 由于前面已经在service.yml中把PersonalAppService应用层服务类，配置成了“bean-service”的聚合服务，所以可以直接进行接口调用：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;send2Payment1\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;Hello world!\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;19620fe5843d4d53a2bf1f599b516006\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631153624870, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;traceId\u0026quot;: \u0026quot;19620fe5843d4d53a2bf1f599b516006\u0026quot;, \u0026quot;code\u0026quot;: 0, \u0026quot;data\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;Hello world!\u0026quot; }, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;timestamp\u0026quot;: 1631153624870 } } }  Payment1SinkApplication应用会收到消息：\n2021-09-09 10:13:44.911 INFO 10756 --- [nio-8003-exec-2] c.x.d.p.service.Payment1DomainService : 传入消息: ====+ 01-02-03-04-05-06-07-08-09-10-11-12-13-14-15-16-17-18-19-20 + ====== ASCII ====== + 0000: 3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E 3D 22 31 2E 30 22 20 | \u0026lt;?xml version=\u0026quot;1.0\u0026quot; | 0020: 65 6E 63 6F 64 69 6E 67 3D 22 55 54 46 2D 38 22 20 73 74 61 | encoding=\u0026quot;UTF-8\u0026quot; sta | 0040: 6E 64 61 6C 6F 6E 65 3D 22 6E 6F 22 3F 3E 3C 72 6F 6F 74 3E | ndalone=\u0026quot;no\u0026quot;?\u0026gt;\u0026lt;root\u0026gt; | 0060: 3C 6D 65 73 73 61 67 65 3E 48 65 6C 6C 6F 20 77 6F 72 6C 64 | \u0026lt;message\u0026gt;Hello world | 0080: 21 3C 2F 6D 65 73 73 61 67 65 3E 3C 2F 72 6F 6F 74 3E | !\u0026lt;/message\u0026gt;\u0026lt;/root\u0026gt;.. |  在适配层中，在原有的PersonalController类中，增加对“/send2Payment1\u0026quot;请求的实现：\n@GetMapping(value =\u0026quot;/send2Payment1\u0026quot;) public BizMessage\u0026lt;JSONObject\u0026gt; send2Payment1(String message) throws BizException { return this.personalAppInterface.send2Payment1(message); }  开发者可以在适配层的PersonalController类中，通过personalAppInterface，把消息发送给缴费平台：\n$ curl http://localhost:9001/personal/send2Payment1\\?message=hello|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;3c9d800b3c76480c9ae605d543709ea3\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631154087879, \u0026quot;data\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;hello\u0026quot; } }  在适配层中，还可以通过配置sink-service类型的聚合服务，直接调用领域层的Sink服务。例如可以在原有的PersonalController类中，直接向应用层发起JSONObject类型的平台报文：\n@RestController @RequestMapping(\u0026quot;/personal\u0026quot;) public class PersonalController { ... private BizMessageInterface payment1SinkInterface = SourceClientFactory .getBizServiceClient(BizMessageInterface.class,\u0026quot;sink/payment1\u0026quot;); ... @GetMapping(value =\u0026quot;/send2Payment\u0026quot;) public BizMessage\u0026lt;JSONObject\u0026gt; send2Payment(String message) throws BizException { JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;message\u0026quot;,message); return this.payment1SinkInterface.call(jsonObject); } }  开发者可以在适配层的PersonalController类中，通过personalAppInterface，把消息发送给缴费平台：\n$ curl http://localhost:9001/personal/send2Payment1\\?message=hello|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;3c9d800b3c76480c9ae605d543709ea3\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631154087879, \u0026quot;data\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;hello\u0026quot; } }  七、项目实践：应用服务对延迟服务的组装 1. SAF存储转发的实现 在领域层中，开发Payment2SinkService，根据tranMode交易模式，实现处理超时、处理失败和处理成功的各种异常情况：\n@Service public class Payment2SinkService implements JSONObjectSinkBeanInterface { @Autowired private TimeoutCmdExe timeoutCmdExe; @Autowired private TimeoutAndFailCmdExe timeoutAndFailCmdExe; @Autowired private TimeoutAndSuccessCmdExe timeoutAndSuccessCmdExe; @Autowired private SuccessCmdExe successCmdExe; @Override public JSONObject process(JSONObject jsonObject) throws BizException { log.info(\u0026quot;传入消息:\\n{}\u0026quot;, jsonObject.toString()); AbstractSinkBeanCmdExe sinkBeanCmdExe; String tranMode = (String)jsonObject.get(\u0026quot;tranMode\u0026quot;); switch (tranMode) { case \u0026quot;timeout\u0026quot;: // 收到交易后，永远返回超时 return timeoutCmdExe.execute(jsonObject); case \u0026quot;3timeout-fail\u0026quot;: // 收到交易后，前3次返回超时，第4次返回失败码 return timeoutAndFailCmdExe.execute(jsonObject); case \u0026quot;3timeout-success\u0026quot;: // 收到交易后，前3次返回超时，第4次成功返回原报文 return timeoutAndSuccessCmdExe.execute(jsonObject); default: //其它情况,成功返回原报文 return successCmdExe.execute(jsonObject); } } }  注意，Payment2领域服务在封装时，涉及到多个接口调用，对每个接口采用命令执行器（Command Executor），这里是传入标准的JSONObject数据，所以所有的接口实现继承AbstractSinkBeanCmdExe类来实现： 在应用层中，在原有的PersonalAppInterface应用层接口、PersonalAppService服务类中，增加send2Payment2()、getCustomerAndSaf2Payment2()这2个方法接口和实现，通过personalAppDelayInterface延迟调用接口，实现对原有send2Payment2()方法的多次SAF调用：\n@Service public class PersonalAppService implements PersonalAppInterface { ... private BizMessageInterface payment2SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment2-sink\u0026quot;); private PersonalAppInterface personalAppDelayInterface = IntegratorClientFactory .getDelayBizServiceClient(PersonalAppInterface.class,\u0026quot;app/personal\u0026quot;, 0,1000,2000,4000,8000,16000,32000); ... @Override public BizMessage send2Payment2(String tranMode, String tranCode, Object message) throws BizException { JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;tranCode\u0026quot;,tranCode); jsonObject.set(\u0026quot;tranMode\u0026quot;,tranMode); jsonObject.set(\u0026quot;message\u0026quot;,message); return this.payment2SinkInterface.call(jsonObject); } @Override public Customer getCustomerAndSaf2Payment2(String tranMode,String customerId) throws BizException { Customer customer = this.customerSinkInterface.getCustomer(customerId); this.personalAppDelayInterface.send2Payment2(tranMode,\u0026quot;send-customer\u0026quot;, customer); return customer; } ... }  传入交易模式为”timeout“（收到交易后，永远返回超时），这将导致发送7次，最后交易状态为失败：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomerAndSaf2Payment2\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;timeout\u0026quot;,\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;c1d2ffb7f0b44bf4b0cb7e13e5c0c0fa\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631274896174, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } }  Payment2SinkApplication日志：\n2021-09-10 19:54:56.650 INFO 14993 --- [nio-8004-exec-3] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:54:56.651 INFO 14993 --- [nio-8004-exec-3] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:54:57.753 INFO 14993 --- [nio-8004-exec-4] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:54:57.754 INFO 14993 --- [nio-8004-exec-4] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:54:59.920 INFO 14993 --- [nio-8004-exec-5] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:54:59.920 INFO 14993 --- [nio-8004-exec-5] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:55:04.015 INFO 14993 --- [nio-8004-exec-6] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:55:04.015 INFO 14993 --- [nio-8004-exec-6] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:55:12.041 INFO 14993 --- [nio-8004-exec-7] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:55:12.042 INFO 14993 --- [nio-8004-exec-7] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:55:28.080 INFO 14993 --- [nio-8004-exec-8] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:55:28.080 INFO 14993 --- [nio-8004-exec-8] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:56:00.228 INFO 14993 --- [nio-8004-exec-9] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;timeout\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:56:00.228 INFO 14993 --- [nio-8004-exec-9] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常!  传入交易码为”3timeout-fail“（收到交易后，前3次返回超时，第4次返回失败），这将导致发送4次，最后交易状态为失败：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomerAndSaf2Payment2\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;3timeout-fail\u0026quot;,\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;d3589b169d654a409c2f7d15f83f5113\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631275051123, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } }  Payment2SinkApplication日志：\n2021-09-10 19:57:31.379 INFO 14993 --- [nio-8004-exec-1] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-fail\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:57:31.379 INFO 14993 --- [nio-8004-exec-1] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:57:32.647 INFO 14993 --- [nio-8004-exec-2] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-fail\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:57:32.647 INFO 14993 --- [nio-8004-exec-2] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:57:34.672 INFO 14993 --- [nio-8004-exec-3] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-fail\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:57:34.673 INFO 14993 --- [nio-8004-exec-3] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:57:38.733 INFO 14993 --- [nio-8004-exec-4] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-fail\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:57:38.733 INFO 14993 --- [nio-8004-exec-4] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回交易处理失败!  传入交易码为”3timeout-success“（收到交易后，前3次返回超时，第4次成功返回原报文），这将导致发送4次，最后交易状态为成功：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;getCustomerAndSaf2Payment2\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;3timeout-success\u0026quot;,\u0026quot;001\u0026quot;]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;75b76cf518164964bedf477ea488698c\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631275117934, \u0026quot;data\u0026quot;: { \u0026quot;result\u0026quot;: { \u0026quot;sex\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;customerName\u0026quot;: \u0026quot;张三\u0026quot;, \u0026quot;customerId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;age\u0026quot;: 30 } } }  Payment2SinkApplication日志：\n2021-09-10 19:58:38.146 INFO 14993 --- [nio-8004-exec-5] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-success\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:58:38.146 INFO 14993 --- [nio-8004-exec-5] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:58:39.200 INFO 14993 --- [nio-8004-exec-6] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-success\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:58:39.200 INFO 14993 --- [nio-8004-exec-6] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:58:41.409 INFO 14993 --- [nio-8004-exec-7] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-success\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:58:41.409 INFO 14993 --- [nio-8004-exec-7] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回超时异常! 2021-09-10 19:58:45.539 INFO 14993 --- [nio-8004-exec-8] c.x.d.p.service.Payment2DomainService : 传入消息: {\u0026quot;tranMode\u0026quot;:\u0026quot;3timeout-success\u0026quot;,\u0026quot;message\u0026quot;:{\u0026quot;sex\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;customerName\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;customerId\u0026quot;:\u0026quot;001\u0026quot;,\u0026quot;age\u0026quot;:30},\u0026quot;tranCode\u0026quot;:\u0026quot;send-customer\u0026quot;} 2021-09-10 19:58:45.539 INFO 14993 --- [nio-8004-exec-8] c.x.d.p.service.Payment2DomainService : 交易:send-customer,返回交易成功!  2. 向前补偿的实现 向前补偿机制是指当交易无应答时，系统会对原交易进行查询，如查询超时会重试多次。如原交易成功则继续后续交易，如原交易失败则对前续交易进行交易补偿，向前补偿一般是针对第三方接入方无法提供补偿交易时的解决方案。 在金融领域，这类交易补偿动作常被称为“冲正”。 在应用层中，在原有的PersonalAppInterface应用层接口、PersonalAppService服务类中，增加payoutForward()、payoutForwardCompensate()这2个方法接口和实现，通过personalAppDelayInterface延迟调用接口，实现对原有payoutForwardCompensate()方法的多次重复延迟调用：\n@Service public class PersonalAppService implements PersonalAppInterface { private AccountSinkInterface accountSinkInterface = IntegratorClientFactory .getSinkClient(AccountSinkInterface.class,\u0026quot;account-sink\u0026quot;); private CustomerSinkInterface customerSinkInterface = IntegratorClientFactory .getSinkClient(CustomerSinkInterface.class,\u0026quot;customer-sink\u0026quot;); private BizMessageInterface payment1SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment1-sink\u0026quot;); private BizMessageInterface payment2SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment2-sink\u0026quot;); private PersonalAppInterface personalAppDelayInterface = IntegratorClientFactory .getDelayBizServiceClient(PersonalAppInterface.class,\u0026quot;app/personal\u0026quot;, 0,1000,2000,4000,8000,16000,32000); ...... @Override public void payoutForward(String tranMode,String accountId, long amount) throws BizException { log.info(\u0026quot;account出金:{},{}\u0026quot;,accountId,amount); this.accountDomainInterface.payout(accountId,amount); JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;tranCode\u0026quot;,\u0026quot;pay\u0026quot;); jsonObject.set(\u0026quot;tranMode\u0026quot;,tranMode); jsonObject.set(\u0026quot;accountId\u0026quot;,accountId); jsonObject.set(\u0026quot;tranAmount\u0026quot;,amount); BizMessage\u0026lt;JSONObject\u0026gt; bizMessage = null; try { log.info(\u0026quot;payment缴费...\u0026quot;); bizMessage = this.payment2SinkInterface.call(jsonObject); } catch (BizException e) { if (e.isTimeOutException()) { log.info(\u0026quot;payment交易超时,开始payout补偿...\u0026quot;); this.personalAppDelayInterface.payoutForwardCompensate(jsonObject); return; } else { throw e; } } log.info(\u0026quot;payment缴费成功!\u0026quot;); log.info(\u0026quot;payout成功!\u0026quot;); } @Override public void payoutForwardCompensate(JSONObject jsonObject) throws BizException{ jsonObject.set(\u0026quot;tranCode\u0026quot;,\u0026quot;pay-query\u0026quot;); BizMessage\u0026lt;JSONObject\u0026gt; bizMessage = null; try { log.info(\u0026quot;payment查询缴费订单...\u0026quot;); bizMessage = this.payment2SinkInterface.call(jsonObject); } catch (BizException e) { if (e.isTimeOutException()) { log.info(\u0026quot;payment交易超时...\u0026quot;); throw e; } else { log.info(\u0026quot;payment查询缴费订单返回错误（表示对方订单没执行）...\u0026quot;); String accountId = (String)jsonObject.get(\u0026quot;accountId\u0026quot;); long amount = (Integer) jsonObject.get(\u0026quot;tranAmount\u0026quot;); log.info(\u0026quot;account出金补偿:{},{}\u0026quot;,accountId,amount); this.accountDomainInterface.payoutCompensation(accountId,amount); return; } } log.info(\u0026quot;payment查询缴费订单成功（表示对方订单已执行）\u0026quot;); log.info(\u0026quot;payout成功!\u0026quot;); }  传入交易模式为”3timeout-success“（收到订单交易后，前3次返回超时，第4次成功返回模拟订单已执行），这将导致发送4次，最后交易状态为成功：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;payoutForward\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;3timeout-success\u0026quot;,\u0026quot;0001\u0026quot;,1]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;e0127a25e2514da682ad77042917087a\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631275840559, \u0026quot;data\u0026quot;: {} }  XbankAppApplication日志：\n[bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:40.560 INFO 16503 [11034350FE38437BB459F1E8DC6CCE17] [http-nio-8888-exec-5] c.xbank.app.service.PersonalAppService account出金:0001,1 [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:40.822 INFO 16503 [11034350FE38437BB459F1E8DC6CCE17] [http-nio-8888-exec-5] c.xbank.app.service.PersonalAppService payment缴费... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:40.831 INFO 16503 [11034350FE38437BB459F1E8DC6CCE17] [http-nio-8888-exec-5] c.xbank.app.service.PersonalAppService payment交易超时,开始payout补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:42.086 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService payment查询缴费订单... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:42.095 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService payment交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:43.268 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-3] c.xbank.app.service.PersonalAppService payment查询缴费订单... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:43.277 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-3] c.xbank.app.service.PersonalAppService payment交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:45.296 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-2] c.xbank.app.service.PersonalAppService payment查询缴费订单... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:45.306 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-2] c.xbank.app.service.PersonalAppService payment查询缴费订单成功（表示对方订单已执行） [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:10:45.306 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-2] c.xbank.app.service.PersonalAppService payout成功!  传入交易模式为”3timeout-success“（收到订单交易后，前3次返回超时，第4次成功返回模拟订单已执行），这将导致发送4次，最后交易状态为成功：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;payoutForward\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;3timeout-fail\u0026quot;,\u0026quot;0001\u0026quot;,1]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;a04163bf05484fa28071650a085d4124\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631275997342, \u0026quot;data\u0026quot;: {} }  XbankAppApplication日志：\n[bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:17.342 INFO 16503 [5E5951618A27430684C5552E1F782D8B] [http-nio-8888-exec-7] c.xbank.app.service.PersonalAppService account出金:0001,1 [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:17.568 INFO 16503 [5E5951618A27430684C5552E1F782D8B] [http-nio-8888-exec-7] c.xbank.app.service.PersonalAppService payment缴费... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:17.579 INFO 16503 [5E5951618A27430684C5552E1F782D8B] [http-nio-8888-exec-7] c.xbank.app.service.PersonalAppService payment交易超时,开始payout补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:17.775 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-5] c.xbank.app.service.PersonalAppService payment查询缴费订单... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:17.788 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-5] c.xbank.app.service.PersonalAppService payment交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:18.827 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-1] c.xbank.app.service.PersonalAppService payment查询缴费订单... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:18.836 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-1] c.xbank.app.service.PersonalAppService payment交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:20.890 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService payment查询缴费订单... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:20.900 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService payment查询缴费订单返回错误（表示对方订单没执行）... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:13:20.901 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService account出金补偿:0001,1  3. 向后补偿的实现 向后补偿机制是指当交易无应答时，系统会对原交易发起多次交易补偿重试，如补偿交易成功则对前续交易进行补偿。 在应用层中，在原有的PersonalAppInterface应用层接口、PersonalAppService服务类中，增加payoutBackward()、payoutBackwardCompensate()这2个方法接口和实现，通过personalAppDelayInterface延迟调用接口，实现对原有payoutForwardCompensate()方法的多次重复延迟调用：\n@Service public class PersonalAppService implements PersonalAppInterface { private AccountSinkInterface accountSinkInterface = IntegratorClientFactory .getSinkClient(AccountSinkInterface.class,\u0026quot;account-sink\u0026quot;); private CustomerSinkInterface customerSinkInterface = IntegratorClientFactory .getSinkClient(CustomerSinkInterface.class,\u0026quot;customer-sink\u0026quot;); private BizMessageInterface payment1SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment1-sink\u0026quot;); private BizMessageInterface payment2SinkInterface = IntegratorClientFactory .getSinkClient(BizMessageInterface.class,\u0026quot;payment2-sink\u0026quot;); private PersonalAppInterface personalAppDelayInterface = IntegratorClientFactory .getDelayBizServiceClient(PersonalAppInterface.class,\u0026quot;app/personal\u0026quot;, 0,1000,2000,4000,8000,16000,32000); ...... @Override public void payoutBackward(String tranMode, String accountId, long amount) throws BizException { log.info(\u0026quot;account出金:{},{}\u0026quot;,accountId,amount); this.accountDomainInterface.payout(accountId,amount); JSONObject jsonObject = new JSONObject(); jsonObject.set(\u0026quot;tranCode\u0026quot;,\u0026quot;pay\u0026quot;); jsonObject.set(\u0026quot;tranMode\u0026quot;,tranMode); jsonObject.set(\u0026quot;accountId\u0026quot;,accountId); jsonObject.set(\u0026quot;tranAmount\u0026quot;,amount); BizMessage\u0026lt;JSONObject\u0026gt; bizMessage = null; try { log.info(\u0026quot;payment缴费...\u0026quot;); bizMessage = this.payment2SinkInterface.call(jsonObject); } catch (BizException e) { if (e.isTimeOutException()) { log.info(\u0026quot;payment交易超时,开始payout冲正...\u0026quot;); this.personalAppDelayInterface.payoutBackwardCompensate(jsonObject); return; } else { log.info(\u0026quot;payment缴费交易返回错误\u0026quot;); log.info(\u0026quot;account出金补偿:{},{}\u0026quot;,accountId,amount); this.accountDomainInterface.payoutCompensation(accountId,amount); log.info(\u0026quot;payout交易补偿成功！\u0026quot;); return; } } log.info(\u0026quot;payment缴费成功\u0026quot;); log.info(\u0026quot;payout成功!\u0026quot;); } @Override public void payoutBackwardCompensate(JSONObject jsonObject) throws BizException { jsonObject.set(\u0026quot;tranCode\u0026quot;,\u0026quot;pay-reversal\u0026quot;); BizMessage\u0026lt;JSONObject\u0026gt; bizMessage; try { log.info(\u0026quot;payment缴费补偿...\u0026quot;); bizMessage = this.payment2SinkInterface.call(jsonObject); log.info(\u0026quot;payment缴费补偿成功\u0026quot;); } catch (BizException e) { if (e.isTimeOutException()) { log.info(\u0026quot;payment缴费补偿交易超时...\u0026quot;); throw e; } log.info(\u0026quot;payment缴费补偿交易失败,需要人工干预调整!\u0026quot;); return; } String accountId = (String)jsonObject.get(\u0026quot;accountId\u0026quot;); long amount = (Integer)jsonObject.get(\u0026quot;tranAmount\u0026quot;); log.info(\u0026quot;account出金补偿:{},{}\u0026quot;,accountId,amount); this.accountDomainInterface.payoutCompensation(accountId,amount); log.info(\u0026quot;payout补偿成功！\u0026quot;); }  传入交易模式为”3timeout-success“（收到订单交易后，前3次返回补偿交易超时，第4次成功返回补偿交易执行成功），这将导致发送4次，最后交易状态为成功：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;payoutBackward\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;3timeout-success\u0026quot;,\u0026quot;0001\u0026quot;,1]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;26c58fe44b3f4ceba462762494fa5981\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631276405513, \u0026quot;data\u0026quot;: {} }  XbankAppApplication日志：\n[bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:05.513 INFO 16503 [84936F44451449C5A92183EF93C3690C] [http-nio-8888-exec-2] c.xbank.app.service.PersonalAppService account出金:0001,1 [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:05.952 INFO 16503 [84936F44451449C5A92183EF93C3690C] [http-nio-8888-exec-2] c.xbank.app.service.PersonalAppService payment缴费... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:05.961 INFO 16503 [84936F44451449C5A92183EF93C3690C] [http-nio-8888-exec-2] c.xbank.app.service.PersonalAppService payment交易超时,开始payout冲正... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:06.396 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-1] c.xbank.app.service.PersonalAppService payment缴费补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:06.405 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-1] c.xbank.app.service.PersonalAppService payment缴费补偿交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:07.468 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService payment缴费补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:07.475 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-4] c.xbank.app.service.PersonalAppService payment缴费补偿交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:09.560 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-3] c.xbank.app.service.PersonalAppService payment缴费补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:09.570 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-3] c.xbank.app.service.PersonalAppService payment缴费补偿成功 [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:09.571 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-3] c.xbank.app.service.PersonalAppService account出金补偿:0001,1 [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:20:09.726 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-3] c.xbank.app.service.PersonalAppService payout补偿成功！  传入交易模式为”3timeout-fail“（收到订单交易后，前3次返回超时，第4次成功返回模拟补偿交易失败），这将导致发送4次，最后交易状态为失败：\n$ curl -H \u0026quot;Content-Type:application/json\u0026quot; -H \u0026quot;Biz-Service-Id:app/personal\u0026quot; -X POST --data '{\u0026quot;methodName\u0026quot;:\u0026quot;payoutBackward\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;3timeout-fail\u0026quot;,\u0026quot;0001\u0026quot;,1]}' http://localhost:8888/api|jq { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;extMessage\u0026quot;: null, \u0026quot;traceId\u0026quot;: \u0026quot;40aed8f06bba436ba67ff93e769d5a33\u0026quot;, \u0026quot;parentTraceId\u0026quot;: null, \u0026quot;timestamp\u0026quot;: 1631276555599, \u0026quot;data\u0026quot;: {} }  XbankAppApplication日志：\n[bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:35.599 INFO 16503 [B54A535614A64492A7A00D987F12B529] [http-nio-8888-exec-4] c.xbank.app.service.PersonalAppService account出金:0001,1 [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:35.760 INFO 16503 [B54A535614A64492A7A00D987F12B529] [http-nio-8888-exec-4] c.xbank.app.service.PersonalAppService payment缴费... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:35.767 INFO 16503 [B54A535614A64492A7A00D987F12B529] [http-nio-8888-exec-4] c.xbank.app.service.PersonalAppService payment交易超时,开始payout冲正... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:35.979 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-2] c.xbank.app.service.PersonalAppService payment缴费补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:35.993 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-2] c.xbank.app.service.PersonalAppService payment缴费补偿交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:37.073 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-5] c.xbank.app.service.PersonalAppService payment缴费补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:37.083 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-5] c.xbank.app.service.PersonalAppService payment缴费补偿交易超时... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:39.111 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-1] c.xbank.app.service.PersonalAppService payment缴费补偿... [bizsip-integrator:192.169.1.101:8888] 2021-09-10 20:22:39.121 INFO 16503 [] [org.springframework.amqp.rabbit.RabbitListenerEndpointContainer#0-1] c.xbank.app.service.PersonalAppService payment缴费补偿交易失败,需要人工干预调整!  八、总结 1. Sink服务（领域层服务）  sink-bean类sink服务  sink接口为BizMessage类型； 基于或接口开发服务类，实现process()方法，2个接口区别在于出入参数的类型，前1个是byte[]类型，后1个是JSONObject类型； 在sink.yml中配置”sink-bean“类型的connector，服务类支持JavaBean和SpringBean二种挂接方式； 在sink.yml中支持多种convert，传入process()方法的参数为经过convert转换后的消息。   bean类sink服务  sink接口为BizMessage类型，JSONObject消息体中包括：className（可选）、methodName（可选）、params（必选），params为JSONArray类型； 可自由开发服务类； 在sink.yml中配置”bean“类型的connector，服务类支持JavaBean和SpringBean二种挂接方式； 在sink.yml中convert只支持simple-json类型（后期可能会取消对于bean类sink服务的convert配置）。    2. Biz-Service聚合服务（应用层服务） integrator接口为带”Biz-Service-Id“header头、以POST方式提交JSON数据，返回为BizMessage类型的JSON串。 在integrator-bean-service、bean-service类聚合服务开发服务类中，可以用IntegratorClientFactory.getSinkClient()和IntegratorClientFactory.getDelayBizServiceClient()，分别获取sink接口访问和延迟Biz-Service聚合服务接口访问的client API接口。 对sink-bean类sink服务，sink接口为BizMessage类型，应采用接口，统一调用call()方法。\n integrator-bean-service类聚合服务  请求提交为JSON数据； 基于接口开发服务类，实现doBizService()方法； 在service.yml中配置”integrator-bean-service“类型的聚合服务，服务类目前只支持JavaBean挂接方式。   bean-service类聚合服务  请求提交为JSON数据，JSON数据中包括：methodName（必选）、params（必选），params为JSONArray类型； 可自由开发服务类； 在service.yml中配置”bean-service“类型的聚合服务，服务类目前只支持SpringBean挂接方式。   sink-service类聚合服务  请求提交为JSON数据，JSON数据根据后端sink服务接口来定； 无需开发代码； 在service.yml中配置”sink-service“类型的聚合服务，并配置关联到后端的sink端口。   script类聚合服务  请求提交为JSON数据即可，在脚本中调用sink前，应按要求转换成sink约定的JSON数据格式； 无需开发Java代码，但需配置聚合服务脚本； 在config/service目录中配置脚本文件，无需在service.yml中配置。    3. 适配层服务  采用Biz-SIP自带OpenAPI接口  Integrator接口为Biz-SIP平台的OpenAPI接口，可以按需对外开放访问。   定制适配层接入模块  引入Souce类，可以根据消息格式转换的定制，自动进行消息格式转换和适配； 通过SourceClientFactory.getBizServiceClient()，获取Biz-Service聚合服务访问接口（具体请参见链接）。    附录1：Biz-SIP运行机制图 附录2：DDD各层功能定位与粒度划分    层级 功能定位 粒度划分     适配层 渠道接入相关的加解密、验签；\n渠道接入通讯连接的对接；\n渠道消息格式的转换；\nOpenAPI的接入； 按接入渠道进行划分；\n渠道入口和出口，可能会拆分，一般渠道入口在适配层，出口由领域层对接；   应用层 统一应用层消息校验；\n领域层服务的组装和编排； 按业务、按系统进行拆分，涉及到1个以上领域服务；   领域层 交易处理；\n第三方对接，包括安全（加解密、验签）、通讯、消息格式的转换； 交易系统，按业务划分；\n对接第三方，按渠道；\n按数据库划分；   基础设施层 数据库DAO；\nHSM安全    ","date":1632441600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1632441600,"objectID":"83740526d34025b48ec117fc1c6c0474","permalink":"http://bizsip.bizmda.com/doc/xbank/","publishdate":"2021-09-24T00:00:00Z","relpermalink":"/doc/xbank/","section":"doc","summary":"通过xbank项目来介绍用Biz-SIP中间件开发一个系统的全流程\n","tags":null,"title":"xbank示例项目","type":"book"},{"authors":[],"categories":null,"content":"Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"http://bizsip.bizmda.com/event/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/event/example/","section":"event","summary":"An example event.","tags":[],"title":"Example Event","type":"event"},{"authors":null,"categories":null,"content":"Congratulations to Jian Yang and Monica Hall for winning the Best Paper Award at the 2020 Conference on Wowchemy for their paper “Learning Wowchemy”.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Integer tempus augue non tempor egestas. Proin nisl nunc, dignissim in accumsan dapibus, auctor ullamcorper neque. Quisque at elit felis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aenean eget elementum odio. Cras interdum eget risus sit amet aliquet. In volutpat, nisl ut fringilla dignissim, arcu nisl suscipit ante, at accumsan sapien nisl eu eros.\nSed eu dui nec ligula bibendum dapibus. Nullam imperdiet auctor tortor, vel cursus mauris malesuada non. Quisque ultrices euismod dapibus. Aenean sed gravida risus. Sed nisi tortor, vulputate nec quam non, placerat porta nisl. Nunc varius lobortis urna, condimentum facilisis ipsum molestie eu. Ut molestie eleifend ligula sed dignissim. Duis ut tellus turpis. Praesent tincidunt, nunc sed congue malesuada, mauris enim maximus massa, eget interdum turpis urna et ante. Morbi sem nisl, cursus quis mollis et, interdum luctus augue. Aliquam laoreet, leo et accumsan tincidunt, libero neque aliquet lectus, a ultricies lorem mi a orci.\nMauris dapibus sem vel magna convallis laoreet. Donec in venenatis urna, vitae sodales odio. Praesent tortor diam, varius non luctus nec, bibendum vel est. Quisque id sem enim. Maecenas at est leo. Vestibulum tristique pellentesque ex, blandit placerat nunc eleifend sit amet. Fusce eget lectus bibendum, accumsan mi quis, luctus sem. Etiam vitae nulla scelerisque, eleifend odio in, euismod quam. Etiam porta ullamcorper massa, vitae gravida turpis euismod quis. Mauris sodales sem ac ultrices viverra. In placerat ultrices sapien. Suspendisse eu arcu hendrerit, luctus tortor cursus, maximus dolor. Proin et velit et quam gravida dapibus. Donec blandit justo ut consequat tristique.\n","date":1606867200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1606867200,"objectID":"2a0ec8a990dbd78a00c4e15a09364b00","permalink":"http://bizsip.bizmda.com/post/20-12-02-icml-best-paper/","publishdate":"2020-12-02T00:00:00Z","relpermalink":"/post/20-12-02-icml-best-paper/","section":"post","summary":"Congratulations to Jian Yang and Monica Hall for winning the Best Paper Award at the 2020 Conference on Wowchemy for their paper “Learning Wowchemy”.\n","tags":null,"title":"Jian Yang and Monica Hall Win the Best Paper Award at Wowchemy 2020","type":"post"},{"authors":null,"categories":null,"content":"Congratulations to Richard Hendricks for winning first place in the Wowchemy Prize.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Integer tempus augue non tempor egestas. Proin nisl nunc, dignissim in accumsan dapibus, auctor ullamcorper neque. Quisque at elit felis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aenean eget elementum odio. Cras interdum eget risus sit amet aliquet. In volutpat, nisl ut fringilla dignissim, arcu nisl suscipit ante, at accumsan sapien nisl eu eros.\nSed eu dui nec ligula bibendum dapibus. Nullam imperdiet auctor tortor, vel cursus mauris malesuada non. Quisque ultrices euismod dapibus. Aenean sed gravida risus. Sed nisi tortor, vulputate nec quam non, placerat porta nisl. Nunc varius lobortis urna, condimentum facilisis ipsum molestie eu. Ut molestie eleifend ligula sed dignissim. Duis ut tellus turpis. Praesent tincidunt, nunc sed congue malesuada, mauris enim maximus massa, eget interdum turpis urna et ante. Morbi sem nisl, cursus quis mollis et, interdum luctus augue. Aliquam laoreet, leo et accumsan tincidunt, libero neque aliquet lectus, a ultricies lorem mi a orci.\nMauris dapibus sem vel magna convallis laoreet. Donec in venenatis urna, vitae sodales odio. Praesent tortor diam, varius non luctus nec, bibendum vel est. Quisque id sem enim. Maecenas at est leo. Vestibulum tristique pellentesque ex, blandit placerat nunc eleifend sit amet. Fusce eget lectus bibendum, accumsan mi quis, luctus sem. Etiam vitae nulla scelerisque, eleifend odio in, euismod quam. Etiam porta ullamcorper massa, vitae gravida turpis euismod quis. Mauris sodales sem ac ultrices viverra. In placerat ultrices sapien. Suspendisse eu arcu hendrerit, luctus tortor cursus, maximus dolor. Proin et velit et quam gravida dapibus. Donec blandit justo ut consequat tristique.\n","date":1606780800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1606780800,"objectID":"be2bd15f022f0d83fe9ffd743881e70c","permalink":"http://bizsip.bizmda.com/post/20-12-01-wowchemy-prize/","publishdate":"2020-12-01T00:00:00Z","relpermalink":"/post/20-12-01-wowchemy-prize/","section":"post","summary":"Congratulations to Richard Hendricks for winning first place in the Wowchemy Prize.\n","tags":null,"title":"Richard Hendricks Wins First Place in the Wowchemy Prize","type":"post"},{"authors":["Nelson Bighetti"],"categories":null,"content":"Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"http://bizsip.bizmda.com/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":["Nelson Bighetti","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.   Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"http://bizsip.bizmda.com/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Nelson Bighetti","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.   Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"http://bizsip.bizmda.com/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"http://bizsip.bizmda.com/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6d99026b9e19e4fa43d5aadf147c7176","permalink":"http://bizsip.bizmda.com/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/contact/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c1d17ff2b20dca0ad6653a3161942b64","permalink":"http://bizsip.bizmda.com/people/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/people/","section":"","summary":"","tags":null,"title":"","type":"widget_page"}]